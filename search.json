[
  {
    "objectID": "sobre.html",
    "href": "sobre.html",
    "title": "Sobre Nós",
    "section": "",
    "text": "Somos um grupo de estudantes apaixonados da FAE com experiências diversas em ciência da computação, estatística, finanças e ciência de dados. Nossos esforços colaborativos se concentram na resolução de problemas do mundo real usando abordagens orientadas por dados."
  },
  {
    "objectID": "sobre.html#nossa-equipe",
    "href": "sobre.html#nossa-equipe",
    "title": "Sobre Nós",
    "section": "",
    "text": "Somos um grupo de estudantes apaixonados da FAE com experiências diversas em ciência da computação, estatística, finanças e ciência de dados. Nossos esforços colaborativos se concentram na resolução de problemas do mundo real usando abordagens orientadas por dados."
  },
  {
    "objectID": "sobre.html#membros-da-equipe",
    "href": "sobre.html#membros-da-equipe",
    "title": "Sobre Nós",
    "section": "Membros da Equipe",
    "text": "Membros da Equipe\n\n\nGabriel Prado\nFunção: Engenheiro de Vendas\nHabilidades: Python, SQL, Análise de Dados, Metodologias Ágeis, Organização, Trabalho em Equipe\n\n\n\n\n\nJosé Marcos\nFunção: Analista de Riscos\nHabilidades: Apresentação de Dados, Manipulação de Dados, Visualização de Dados, Estatística\n\n\n\n\n\nLucas Kainã\nFunção: Analista de Negócios\nHabilidades: Análise Financeira, Análise Exploratória de dados, Modelagem Preditiva\n\n\n\n\n\nArthur Liz\nFunção: Analista Financeiro\nHabilidades: Análise financeira, Modelagem preditiva, Python, R, SQL, Power BI, Looker Studio, Tableau"
  },
  {
    "objectID": "sobre.html#nossa-abordagem",
    "href": "sobre.html#nossa-abordagem",
    "title": "Sobre Nós",
    "section": "Nossa Abordagem",
    "text": "Nossa Abordagem\nAcreditamos na aprendizagem colaborativa e na aplicação prática de técnicas de ciência de dados. Nossos projetos combinam conhecimento acadêmico com aplicações do mundo real, particularmente no setor financeiro.\nNosso fluxo de trabalho geralmente inclui:\n\nDefinição do problema e pesquisa\nColeta e pré-processamento de dados\nAnálise exploratória de dados\nDesenvolvimento e teste de modelos\nVisualização e comunicação de resultados\nMelhoria contínua e iteração"
  },
  {
    "objectID": "sobre.html#informações-do-curso",
    "href": "sobre.html#informações-do-curso",
    "title": "Sobre Nós",
    "section": "Informações do Curso",
    "text": "Informações do Curso\nEste portfólio foi criado como parte do curso Big Data for Finance Project na FAE Business School. Conduzida por:\n\nProfessor Rodrigo H. Ozon"
  },
  {
    "objectID": "semana2.html",
    "href": "semana2.html",
    "title": "Semana 2: Modelagem de Dados para Portfólios Financeiros",
    "section": "",
    "text": "Nesta aula, abordaremos um dos pilares fundamentais da modelagem quantitativa em finanças: a utilização de dados financeiros para a construção e análise de portfólios. Exploraremos três grandes abordagens no uso de séries temporais financeiras, focando principalmente na geração de dados sintéticos para nossa análise.\nPara tal, exploraremos três grandes abordagens no uso de séries temporais financeiras:\nObtenção de dados reais via APIs - Demonstramos como utilizar APIs públicas, como a do Yahoo Finance, para baixar dados históricos de ações e commodities, diretamente para o R ou Python. - O objetivo é capacitar os alunos a construir portfólios reais, utilizando fontes públicas de dados financeiros. Geração de dados sintéticos - Introduzimos métodos para gerar dados sintéticos, como o Movimento Browniano Geométrico (MGB), distribuições lognormais, caminhos aleatórios com ruído gaussiano e redes adversariais generativas (GANs). - O propósito desses métodos é fornecer alternativas para análise de portfólios quando não há dados reais disponíveis ou quando há restrições de privacidade e confidencialidade.\n\n\n\n\n\n\nNote\n\n\n\nPor que isso é importante? - Muitas vezes, dados reais são incompletos, inconsistentes ou indisponíveis, tornando essencial o conhecimento de técnicas de simulação e modelagem de séries temporais. - O aprendizado dessas abordagens permite aos alunos tomar decisões informadas sobre quais métodos utilizar na modelagem de portfólios financeiros, seja para análise de risco, previsão de preços ou otimização de carteiras.\n\n\n\n\n\n\n\n\nTip\n\n\n\nObjetivo da aula - Compreender as vantagens e limitações de cada uma dessas abordagens. - Desenvolver habilidades práticas na obtenção e manipulação de dados financeiros. - Implementar técnicas para análise e simulação de portfólios, combinando ferramentas do R e Python."
  },
  {
    "objectID": "semana2.html#justificativa-da-escolha",
    "href": "semana2.html#justificativa-da-escolha",
    "title": "Semana 2: Modelagem de Dados para Portfólios Financeiros",
    "section": "3.1 Justificativa da Escolha",
    "text": "3.1 Justificativa da Escolha\nApós analisar os diversos métodos de geração de dados sintéticos apresentados na tabela, optamos pelo Movimento Browniano Geométrico (MBG) pelos seguintes motivos:\n\nSimplicidade e Eficiência: O MBG é um método relativamente simples de implementar, mas ainda assim eficaz para gerar séries temporais financeiras sintéticas.\nBase Teórica Sólida: Fundamentado na teoria financeira clássica, é amplamente aceito como um modelo padrão para simulação de preços de ativos.\nAdequação para Portfólios: É particularmente adequado para modelar preços de ações e outros ativos financeiros no longo prazo.\nReprodutibilidade: Permite gerar múltiplas simulações com parâmetros consistentes, facilitando testes de robustez.\nMenor Complexidade Computacional: Comparado com modelos como GANs, TimeGAN, ou Processo de Heston, o MBG requer significativamente menos recursos computacionais."
  },
  {
    "objectID": "semana2.html#por-que-não-escolhemos-outros-métodos",
    "href": "semana2.html#por-que-não-escolhemos-outros-métodos",
    "title": "Semana 2: Modelagem de Dados para Portfólios Financeiros",
    "section": "3.2 Por que não escolhemos outros métodos?",
    "text": "3.2 Por que não escolhemos outros métodos?\n\nGANs e TimeGAN: Embora capturem padrões complexos, exigem treinamento extensivo, grandes volumes de dados e são computacionalmente intensivos.\nProcesso de Heston: Apesar de modelar volatilidade estocástica de forma realista, apresenta complexidade matemática e computacional elevada.\nAutoencoders Variacionais: Podem perder informações importantes sobre a variabilidade estocástica dos dados financeiros.\nRNNs e LSTMs: Necessitam de grandes volumes de dados para treinamento e podem ser excessivamente complexos para o escopo atual."
  },
  {
    "objectID": "semana2.html#coleta-de-dados-reais-para-estimativa-de-parâmetros",
    "href": "semana2.html#coleta-de-dados-reais-para-estimativa-de-parâmetros",
    "title": "Semana 2: Modelagem de Dados para Portfólios Financeiros",
    "section": "4.1 Coleta de dados reais para estimativa de parâmetros",
    "text": "4.1 Coleta de dados reais para estimativa de parâmetros\nVamos baixar dados históricos para estimar os parâmetros necessários para o modelo MBG:\n\n# Definir tickers da carteira\ntickers &lt;- c(\"NVDA\", \"AAPL\", \"TSLA\", \"META\", \"AMZN\", \"MSFT\")\n\n# Definir período para coleta\nend_date &lt;- Sys.Date()\nstart_date &lt;- end_date - 365*2  # 2 anos para estimar parâmetros\n\n# Baixar dados históricos\ngetSymbols(tickers, from = start_date, to = end_date, src = \"yahoo\")\n\n[1] \"NVDA\" \"AAPL\" \"TSLA\" \"META\" \"AMZN\" \"MSFT\"\n\n# Extrair preços de fechamento ajustados\nprices &lt;- do.call(merge, lapply(tickers, function(ticker) {\n  Cl(get(ticker))\n}))\ncolnames(prices) &lt;- tickers\n\n# Visualizar os primeiros registros\nhead(prices)\n\n             NVDA   AAPL   TSLA   META   AMZN   MSFT\n2023-04-10 27.579 162.03 184.51 214.75 102.17 289.39\n2023-04-11 27.169 160.80 186.79 213.85  99.92 282.83\n2023-04-12 26.495 160.10 180.54 214.00  97.83 283.49\n2023-04-13 26.463 165.56 185.90 220.35 102.40 289.84\n2023-04-14 26.758 165.21 185.00 221.49 102.51 286.14\n2023-04-17 27.002 165.23 187.04 218.86 102.74 288.80"
  },
  {
    "objectID": "semana2.html#calcular-retornos-e-estimar-parâmetros",
    "href": "semana2.html#calcular-retornos-e-estimar-parâmetros",
    "title": "Semana 2: Modelagem de Dados para Portfólios Financeiros",
    "section": "4.2 Calcular retornos e estimar parâmetros",
    "text": "4.2 Calcular retornos e estimar parâmetros\n\n# Calcular retornos diários\nreturns &lt;- na.omit(Return.calculate(prices, method = \"log\"))\n\n# Calcular parâmetros para o MBG\nmu &lt;- colMeans(returns) * 252  # Drift anualizado\nsigma &lt;- apply(returns, 2, sd) * sqrt(252)  # Volatilidade anualizada\n\n# Exibir parâmetros estimados\ndata.frame(ticker = tickers, mu = mu, sigma = sigma)\n\n     ticker         mu     sigma\nNVDA   NVDA 0.62092627 0.5228523\nAAPL   AAPL 0.07609477 0.2379770\nTSLA   TSLA 0.13158412 0.5960538\nMETA   META 0.43155585 0.3451593\nAMZN   AMZN 0.26009303 0.3013134\nMSFT   MSFT 0.11003369 0.2212491"
  },
  {
    "objectID": "semana2.html#implementação-do-mbg-em-r",
    "href": "semana2.html#implementação-do-mbg-em-r",
    "title": "Semana 2: Modelagem de Dados para Portfólios Financeiros",
    "section": "4.3 Implementação do MBG em R",
    "text": "4.3 Implementação do MBG em R\n\n# Função otimizada para gerar séries temporais sintéticas usando MBG\ngenerate_gbm_optimized &lt;- function(S0, mu, sigma, T = 1, N = 252, seed = NULL) {\n  # Parâmetros:\n  # S0: Vetor de preços iniciais\n  # mu: Vetor de drifts (retornos médios anualizados)\n  # sigma: Vetor de volatilidades anualizadas\n  # T: Horizonte de tempo em anos (padrão: 1 ano)\n  # N: Número de dias de trading (padrão: 252 dias úteis)\n  # seed: Semente para reprodutibilidade (opcional)\n  \n  # Validação de entrada\n  if (length(S0) != length(mu) || length(mu) != length(sigma)) {\n    stop(\"Os vetores S0, mu e sigma devem ter o mesmo comprimento\")\n  }\n  \n  # Definir semente se fornecida\n  if (!is.null(seed)) set.seed(seed)\n  \n  # Número de ativos\n  n_assets &lt;- length(S0)\n  \n  # Converter parâmetros para escala diária\n  dt &lt;- T/N\n  mu_daily &lt;- mu\n  sigma_daily &lt;- sigma\n  \n  # Inicializar matriz de preços\n  prices &lt;- matrix(0, nrow = N+1, ncol = n_assets)\n  prices[1,] &lt;- S0\n  \n  # Pré-computar termos que não mudam no loop\n  drift_term &lt;- (mu_daily - 0.5 * sigma_daily^2) * dt\n  vol_term &lt;- sigma_daily * sqrt(dt)\n  \n  # Usar vectorização para maior eficiência\n  for (i in 1:n_assets) {\n    # Gerar números aleatórios de uma vez\n    Z &lt;- rnorm(N, 0, 1)\n    \n    # Calcular incrementos logarítmicos cumulativos\n    log_returns &lt;- cumsum(drift_term[i] + vol_term[i] * Z)\n    \n    # Converter para preços\n    prices[2:(N+1), i] &lt;- S0[i] * exp(log_returns)\n  }\n  \n  # Criar datas para simulação (dias úteis)\n  today &lt;- Sys.Date()\n  future_dates &lt;- seq(today, by = \"day\", length.out = N*2)  # Dias extras para compensar fins de semana\n  \n  # Filtrar apenas dias úteis (segunda a sexta)\n  weekdays_only &lt;- future_dates[!weekdays(future_dates) %in% c(\"Saturday\", \"Sunday\")]\n  future_dates &lt;- weekdays_only[1:(N+1)]  # Pegar apenas o número necessário de dias\n  \n  # Criar xts object\n  library(xts)\n  synthetic_prices &lt;- xts(prices, order.by = future_dates)\n  \n  # Nomes das colunas\n  if (!is.null(names(S0))) {\n    colnames(synthetic_prices) &lt;- names(S0)\n  } else {\n    colnames(synthetic_prices) &lt;- paste0(\"Asset\", 1:n_assets)\n  }\n  \n  return(synthetic_prices)\n}\n\n# Exemplo de uso\n# Configuração dos parâmetros\ntickers &lt;- c(\"NVDA\", \"AAPL\", \"TSLA\", \"META\", \"AMZN\", \"MSFT\")\nS0 &lt;- c(30.5, 68.2, 27.8, 173.4, 305.2, 130.1)  # Preços iniciais\nnames(S0) &lt;- tickers\nmu &lt;- c(0.10, 0.08, 0.05, 0.12, 0.09, 0.11)  # Retornos anualizados\nnames(mu) &lt;- tickers\nsigma &lt;- c(0.30, 0.25, 0.20, 0.28, 0.22, 0.35)  # Volatilidades anualizadas\nnames(sigma) &lt;- tickers\n\n# Gerar preços sintéticos\nsynthetic_prices &lt;- generate_gbm_optimized(S0, mu, sigma, T = 1, N = 252, seed = 123)\n\n# Visualizar os primeiros registros\nhead(synthetic_prices)\n\n               NVDA     AAPL     TSLA     META     AMZN     MSFT\n2025-04-07 30.50000 68.20000 27.80000 173.4000 305.2000 130.1000\n2025-04-08 30.18524 67.84474 27.27966 176.5822 308.1924 132.2694\n2025-04-09 30.06078 67.95464 27.25022 176.0123 306.3693 134.5105\n2025-04-10 30.96620 69.70054 26.94756 169.8529 318.5631 133.7597\n2025-04-11 31.01426 69.61686 26.25674 169.3214 331.4021 132.8668\n2025-04-12 31.09692 70.82565 26.30958 170.9960 325.9369 133.1083\n\n# Calcular retornos\nsynthetic_returns &lt;- na.omit(Return.calculate(synthetic_prices, method = \"log\"))"
  },
  {
    "objectID": "semana2.html#gerar-e-analisar-dados-sintéticos",
    "href": "semana2.html#gerar-e-analisar-dados-sintéticos",
    "title": "Semana 2: Modelagem de Dados para Portfólios Financeiros",
    "section": "4.4 Gerar e analisar dados sintéticos",
    "text": "4.4 Gerar e analisar dados sintéticos\n\n# Parâmetros para simulação\nT &lt;- 1  # Horizonte de tempo (1 ano)\nN &lt;- 252  # Número de dias de trading em um ano\nS0 &lt;- as.numeric(last(prices))  # Preços iniciais\nnames(S0) &lt;- tickers\n\n# Gerar preços sintéticos\nset.seed(123)  # Para reprodutibilidade\nsynthetic_prices &lt;- generate_gbm_optimized(S0, mu, sigma, T, N)\n\n# Visualizar os primeiros registros\nhead(synthetic_prices)\n\n               NVDA     AAPL     TSLA     META     AMZN     MSFT\n2025-04-07 94.31000 188.3800 239.4300 504.7300 171.0000 359.8400\n2025-04-08 93.33671 187.3987 234.9485 513.9927 172.6766 365.8402\n2025-04-09 92.95186 187.7023 234.6950 512.3337 171.6551 372.0390\n2025-04-10 95.75155 192.5248 232.0883 494.4053 178.4872 369.9622\n2025-04-11 95.90015 192.2936 226.1386 492.8580 185.6808 367.4926\n2025-04-12 96.15574 195.6325 226.5936 497.7324 182.6187 368.1606\n\n# Calcular retornos dos preços sintéticos\nsynthetic_returns &lt;- na.omit(Return.calculate(synthetic_prices, method = \"log\"))"
  },
  {
    "objectID": "semana2.html#visualização-dos-preços-sintéticos",
    "href": "semana2.html#visualização-dos-preços-sintéticos",
    "title": "Semana 2: Modelagem de Dados para Portfólios Financeiros",
    "section": "4.5 Visualização dos preços sintéticos",
    "text": "4.5 Visualização dos preços sintéticos\n\n# Converter para formato longo para ggplot\nprices_long &lt;- fortify(synthetic_prices)\nprices_long &lt;- melt(prices_long, id.vars = \"Index\")\n\n# Plotar preços sintéticos\nggplot(prices_long, aes(x = Index, y = value, color = variable)) +\n  geom_line() +\n  labs(title = \"Preços Sintéticos Gerados por Movimento Browniano Geométrico\",\n       x = \"Data\", y = \"Preço\", color = \"Ativo\") +\n  theme_minimal() +\n  theme(legend.position = \"bottom\")"
  },
  {
    "objectID": "semana2.html#comparação-das-distribuições-de-retornos",
    "href": "semana2.html#comparação-das-distribuições-de-retornos",
    "title": "Semana 2: Modelagem de Dados para Portfólios Financeiros",
    "section": "4.6 Comparação das distribuições de retornos",
    "text": "4.6 Comparação das distribuições de retornos\n\npar(mfrow = c(3, 3))\nfor (ticker in tickers) {\n  hist(returns[, ticker], breaks = 30, main = paste(\"Retornos Reais -\", ticker),\n       xlab = \"Retorno\", col = \"lightblue\", probability = TRUE)\n  lines(density(returns[, ticker]), col = \"red\", lwd = 2)\n  \n  hist(synthetic_returns[, ticker], breaks = 30, main = paste(\"Retornos Sintéticos -\", ticker),\n       xlab = \"Retorno\", col = \"lightgreen\", probability = TRUE)\n  lines(density(synthetic_returns[, ticker]), col = \"blue\", lwd = 2)\n}"
  },
  {
    "objectID": "semana2.html#análise-de-correlações",
    "href": "semana2.html#análise-de-correlações",
    "title": "Semana 2: Modelagem de Dados para Portfólios Financeiros",
    "section": "4.7 Análise de correlações",
    "text": "4.7 Análise de correlações\n\n# Correlação dos retornos reais\ncor_real &lt;- cor(returns)\n\n# Correlação dos retornos sintéticos\ncor_synth &lt;- cor(synthetic_returns)\n\n# Visualizar matrizes de correlação\npar(mfrow = c(1, 2))\ncorrplot(cor_real, method = \"color\", type = \"upper\", title = \"Correlação Real\",\n         tl.col = \"black\", tl.srt = 45, addCoef.col = \"black\", number.cex = 0.7)\n\ncorrplot(cor_synth, method = \"color\", type = \"upper\", title = \"Correlação Sintética\",\n         tl.col = \"black\", tl.srt = 45, addCoef.col = \"black\", number.cex = 0.7)"
  },
  {
    "objectID": "semana2.html#visualização-da-fronteira-eficiente",
    "href": "semana2.html#visualização-da-fronteira-eficiente",
    "title": "Semana 2: Modelagem de Dados para Portfólios Financeiros",
    "section": "5.1 Visualização da Fronteira Eficiente",
    "text": "5.1 Visualização da Fronteira Eficiente\n\n# Plotar a fronteira eficiente\nggplot(portfolios, aes(x = risk, y = return, color = sharpe)) +\n  geom_point(alpha = 0.3) +\n  geom_point(aes(x = all_risks[max_sharpe_idx], y = all_returns[max_sharpe_idx]), \n             color = \"red\", size = 5) +\n  labs(title = \"Fronteira Eficiente (Dados Sintéticos)\",\n       x = \"Volatilidade (Risco)\", y = \"Retorno Esperado\") +\n  scale_color_viridis_c(name = \"Índice de Sharpe\") +\n  theme_minimal() +\n  annotate(\"text\", x = all_risks[max_sharpe_idx] + 0.02, \n           y = all_returns[max_sharpe_idx], \n           label = \"Portfólio Ótimo\", color = \"red\")"
  },
  {
    "objectID": "semana2.html#visualização-da-comparação",
    "href": "semana2.html#visualização-da-comparação",
    "title": "Semana 2: Modelagem de Dados para Portfólios Financeiros",
    "section": "6.1 Visualização da Comparação",
    "text": "6.1 Visualização da Comparação\n\n# Converter para formato longo para ggplot\ncomparison_long &lt;- melt(comparison, id.vars = \"ticker\", \n                        measure.vars = c(\"synthetic\", \"real\"),\n                        variable.name = \"data_type\", value.name = \"weight\")\n\n# Plotar comparação\nggplot(comparison_long, aes(x = ticker, y = weight, fill = data_type)) +\n  geom_bar(stat = \"identity\", position = \"dodge\") +\n  labs(title = \"Comparação das Alocações Ótimas\",\n       x = \"Ativo\", y = \"Peso (%)\", fill = \"Tipo de Dados\") +\n  theme_minimal() +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1))"
  },
  {
    "objectID": "semana2.html#análise-dos-resultados",
    "href": "semana2.html#análise-dos-resultados",
    "title": "Semana 2: Modelagem de Dados para Portfólios Financeiros",
    "section": "9.1 Análise dos Resultados",
    "text": "9.1 Análise dos Resultados\nO Movimento Browniano Geométrico nos permitiu gerar dados sintéticos que mantêm muitas das propriedades estatísticas dos dados reais. Observamos:\n\nDistribuição dos Retornos: Os retornos sintéticos apresentam distribuições semelhantes às dos dados reais, com caudas gordas típicas de séries financeiras.\nCorrelações entre Ativos: O modelo preserva as correlações entre os diferentes ativos, aspecto crucial para a diversificação do portfólio.\nVolatilidade Realista: Os preços sintéticos apresentam níveis de volatilidade semelhantes aos observados nos dados históricos.\nOtimização de Portfólio: A alocação ótima calculada com dados sintéticos se aproxima da alocação calculada com dados reais, validando a qualidade dos dados gerados."
  },
  {
    "objectID": "semana2.html#limitações-do-método-escolhido",
    "href": "semana2.html#limitações-do-método-escolhido",
    "title": "Semana 2: Modelagem de Dados para Portfólios Financeiros",
    "section": "9.2 Limitações do Método Escolhido",
    "text": "9.2 Limitações do Método Escolhido\nEmbora o MBG seja adequado para nosso propósito, é importante reconhecer suas limitações:\n\nNão captura mudanças abruptas de volatilidade ou choques de mercado\nAssume volatilidade constante ao longo do tempo\nNão incorpora efeitos de autocorrelação ou sazonalidade\nAssume que os retornos seguem uma distribuição normal, o que nem sempre é verificado em dados financeiros reais\n\nPara análises mais sofisticadas, métodos como o Processo de Heston ou modelos baseados em aprendizado profundo poderiam ser considerados, apesar da maior complexidade computacional."
  },
  {
    "objectID": "semana2.html#conclusão",
    "href": "semana2.html#conclusão",
    "title": "Semana 2: Modelagem de Dados para Portfólios Financeiros",
    "section": "9.3 Conclusão",
    "text": "9.3 Conclusão\nO Movimento Browniano Geométrico oferece um equilíbrio adequado entre simplicidade de implementação e qualidade dos dados sintéticos gerados, sendo suficiente para nossas análises de portfólio. A implementação realizada nos permite gerar cenários sintéticos que mantêm as principais características estatísticas dos dados reais, possibilitando análises de otimização e simulações de diferentes cenários de mercado.\nEste método pode ser particularmente útil em situações onde:\n\nDados históricos são insuficientes ou contêm muitos valores ausentes\nDesejamos testar estratégias de investimento em cenários hipotéticos\nPrecisamos garantir a privacidade dos dados reais\nQueremos gerar múltiplos cenários para análise de risco\n\nNo entanto, para aplicações que exijam maior precisão ou para a captura de dinâmicas mais complexas do mercado, pode ser necessário recorrer a métodos mais sofisticados como os discutidos na tabela comparativa."
  },
  {
    "objectID": "projetos.html",
    "href": "projetos.html",
    "title": "Nossos Projetos",
    "section": "",
    "text": "Este projeto se concentra na análise de grandes conjuntos de dados financeiros para extrair insights e padrões significativos. Implementamos vários algoritmos de machine learning para prever movimentos do mercado e identificar oportunidades de investimento.\n\n\n\n\nAnálise de Séries Temporais\nProcessamento de Linguagem Natural para Análise de Sentimento de Notícias\nMachine Learning para Previsão\nVisualizações Interativas\n\n\n\n\n\nDescobrimos correlação entre o sentimento nas redes sociais e os movimentos do mercado\nCriamos um modelo preditivo com 78% de precisão para mudanças de preço de curto prazo\nDesenvolvemos um painel interativo para análise de mercado em tempo real\n\n\n\n\n\nMontando a carteira de investimentos do grupo (07/03)\nGeração de dados sintéticos x datasets de séries de preços conhecidos (14/03)\nFeature Engineering em Séries de Ações de Tecnologia (21/03)"
  },
  {
    "objectID": "projetos.html#big-data-for-finance-project",
    "href": "projetos.html#big-data-for-finance-project",
    "title": "Nossos Projetos",
    "section": "",
    "text": "Este projeto se concentra na análise de grandes conjuntos de dados financeiros para extrair insights e padrões significativos. Implementamos vários algoritmos de machine learning para prever movimentos do mercado e identificar oportunidades de investimento.\n\n\n\n\nAnálise de Séries Temporais\nProcessamento de Linguagem Natural para Análise de Sentimento de Notícias\nMachine Learning para Previsão\nVisualizações Interativas\n\n\n\n\n\nDescobrimos correlação entre o sentimento nas redes sociais e os movimentos do mercado\nCriamos um modelo preditivo com 78% de precisão para mudanças de preço de curto prazo\nDesenvolvemos um painel interativo para análise de mercado em tempo real\n\n\n\n\n\nMontando a carteira de investimentos do grupo (07/03)\nGeração de dados sintéticos x datasets de séries de preços conhecidos (14/03)\nFeature Engineering em Séries de Ações de Tecnologia (21/03)"
  },
  {
    "objectID": "projetos.html#outros-projetos",
    "href": "projetos.html#outros-projetos",
    "title": "Nossos Projetos",
    "section": "Outros Projetos",
    "text": "Outros Projetos\n\nDesafio de Visualização de Dados\nUm projeto de visualização que transforma dados financeiros complexos em gráficos intuitivos e interativos para melhor tomada de decisões.\n\n\nSimulação de Negociação Algorítmica\nDesenvolvemos um ambiente de negociação simulado para testar várias estratégias algorítmicas contra dados históricos do mercado.\n\n\nFerramenta de Avaliação de Risco Financeiro\nCriamos uma ferramenta que avalia carteiras de investimento e fornece avaliações de risco com base na volatilidade do mercado e nas correlações de ativos."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Portfólio - CLAPS",
    "section": "",
    "text": "Somos um grupo de estudantes do curso de Ciência de Dados da FAE Business School, trabalhando juntos em vários projetos de ciência de dados e big data. Este portfólio apresenta nosso trabalho colaborativo e nossas conquistas."
  },
  {
    "objectID": "index.html#bem-vindo-ao-nosso-portfólio",
    "href": "index.html#bem-vindo-ao-nosso-portfólio",
    "title": "Portfólio - CLAPS",
    "section": "",
    "text": "Somos um grupo de estudantes do curso de Ciência de Dados da FAE Business School, trabalhando juntos em vários projetos de ciência de dados e big data. Este portfólio apresenta nosso trabalho colaborativo e nossas conquistas."
  },
  {
    "objectID": "index.html#projeto-em-destaque",
    "href": "index.html#projeto-em-destaque",
    "title": "Portfólio - CLAPS",
    "section": "Projeto em Destaque",
    "text": "Projeto em Destaque\n\n\n\n\n\n\nBig Data for Finance Project\nNosso projeto principal envolve a análise de dados do mercado financeiro para identificar padrões e fazer previsões. Implementamos vários algoritmos de machine learning e técnicas de visualização.\nVer Detalhes do Projeto →"
  },
  {
    "objectID": "index.html#membros-do-grupo",
    "href": "index.html#membros-do-grupo",
    "title": "Portfólio - CLAPS",
    "section": "Membros do Grupo",
    "text": "Membros do Grupo\n\nGabriel Prado - Engenheiro de Vendas/Gestão de Projetos\nJosé Marcos - Analista de Risco/Programação\nLucas Kainã - Analista de Negócios/Finanças Corporativas\nArthur Liz - Analista Financeiro/Gestão Operacional"
  },
  {
    "objectID": "index.html#tecnologias-que-utilizamos",
    "href": "index.html#tecnologias-que-utilizamos",
    "title": "Portfólio - CLAPS",
    "section": "Tecnologias que Utilizamos",
    "text": "Tecnologias que Utilizamos\n\nR/Python para Análise de Dados\nQuarto para Documentação\nGitHub para Colaboração\nBibliotecas de Machine Learning\nIntegração com APIs Financeiras"
  },
  {
    "objectID": "semana1.html",
    "href": "semana1.html",
    "title": "Semana 1: Análise de Carteira de Investimentos",
    "section": "",
    "text": "Neste projeto, analisaremos uma carteira de investimentos composta por seis empresas líderes de tecnologia. A seleção foi feita com base na relevância destas empresas no setor tecnológico, sua capitalização de mercado e potencial de crescimento.\n\n\n\nNossa carteira é composta pelos seguintes ativos:\n\nNVDA (NVIDIA Corporation)\nAAPL (Apple Inc.)\nTSLA (Tesla, Inc.)\nMETA (Meta Platforms, Inc.)\nAMZN (Amazon.com, Inc.)\nMSFT (Microsoft Corporation)\n\n\n\n\nA carteira foi estruturada com base nos seguintes critérios:\n\nDiversificação dentro do setor tecnológico: Embora todas sejam empresas de tecnologia, cada uma atua em segmentos distintos - hardware, software, redes sociais, comércio eletrônico, veículos elétricos e inteligência artificial.\nExposição à inovação: Todas as empresas selecionadas investem fortemente em pesquisa e desenvolvimento, com foco em tecnologias emergentes como inteligência artificial, realidade aumentada, computação em nuvem e veículos autônomos.\nLiderança de mercado: Todas são líderes em seus respectivos segmentos, com forte presença global e vantagens competitivas significativas.\nPotencial de crescimento: Apesar de já serem empresas consolidadas, continuam apresentando perspectivas de crescimento em novos mercados e através de inovações disruptivas.\n\n\n\n\nPara este projeto, utilizaremos o pacote quantmod em R para coletar os dados históricos de preços das ações selecionadas. Vamos coletar dados dos últimos 2 anos:\n\n\nCode\n# Carregando as bibliotecas necessárias\nlibrary(quantmod)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(corrplot)\nlibrary(RColorBrewer)\nlibrary(scales)\n\n# Definindo os tickers da nossa carteira\ntickers &lt;- c(\"NVDA\", \"AAPL\", \"TSLA\", \"META\", \"AMZN\", \"MSFT\")\n\n# Definindo o período de análise (últimos 2 anos)\nend_date &lt;- Sys.Date()\nstart_date &lt;- end_date - 365*2\n\n# Configurando o ambiente gráfico\noptions(repr.plot.width = 12, repr.plot.height = 8)\n\n# Função para adicionar sufixo ao ticker para Yahoo Finance\nadd_yahoo_suffix &lt;- function(ticker) {\n  return(paste0(ticker, \".US\"))\n}\n\n# Coletando dados históricos\ngetSymbols(tickers, src = \"yahoo\", from = start_date, to = end_date)\n\n\n[1] \"NVDA\" \"AAPL\" \"TSLA\" \"META\" \"AMZN\" \"MSFT\"\n\n\nCode\n# Exibindo as primeiras linhas dos dados da NVIDIA como exemplo\nhead(NVDA)\n\n\n           NVDA.Open NVDA.High NVDA.Low NVDA.Close NVDA.Volume NVDA.Adjusted\n2023-04-10    26.823    27.621   26.669     27.579   395279000      27.56110\n2023-04-11    27.724    27.790   27.126     27.169   314378000      27.15137\n2023-04-12    27.370    27.468   26.448     26.495   446259000      26.47780\n2023-04-13    26.734    26.887   26.329     26.463   353615000      26.44583\n2023-04-14    26.504    26.883   26.220     26.758   395660000      26.74063\n2023-04-17    26.565    27.006   26.433     27.002   321471000      26.98447\n\n\n\n\n\nVamos organizar os dados para facilitar as análises:\n\n\nCode\n# Função para extrair preços de fechamento ajustados\nget_adjusted_prices &lt;- function(ticker) {\n  return(Ad(get(ticker)))\n}\n\n# Criando um dataframe com os preços de fechamento ajustados\nclosing_prices &lt;- do.call(merge, lapply(tickers, get_adjusted_prices))\ncolnames(closing_prices) &lt;- tickers\n\n# Visualizando as primeiras linhas\nhead(closing_prices)\n\n\n               NVDA     AAPL   TSLA     META   AMZN     MSFT\n2023-04-10 27.56110 160.4123 184.51 213.7426 102.17 284.8594\n2023-04-11 27.15137 159.1946 186.79 212.8468  99.92 278.4021\n2023-04-12 26.47780 158.5016 180.54 212.9961  97.83 279.0518\n2023-04-13 26.44583 163.9070 185.90 219.3164 102.40 285.3024\n2023-04-14 26.74063 163.5605 185.00 220.4510 102.51 281.6603\n2023-04-17 26.98447 163.5803 187.04 217.8333 102.74 284.2786\n\n\nCode\n# Convertendo para dataframe para facilitar algumas manipulações\nclosing_prices_df &lt;- as.data.frame(closing_prices)\nclosing_prices_df$date &lt;- as.Date(rownames(closing_prices_df))\n\n\n\n\n\nVamos visualizar a evolução dos preços de fechamento ajustados para cada ativo ao longo do tempo:\n\n\nCode\n# Transformando os dados para o formato longo (tidy)\nprices_long &lt;- closing_prices_df %&gt;%\n  pivot_longer(cols = all_of(tickers), \n               names_to = \"symbol\", \n               values_to = \"price\")\n\n# Plotando os preços de fechamento ajustados\nggplot(prices_long, aes(x = date, y = price, color = symbol)) +\n  geom_line(linewidth = 1) +\n  labs(title = \"Preços de Fechamento Ajustados\",\n       x = \"Data\", \n       y = \"Preço ($)\",\n       color = \"Ticker\") +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(size = 16, face = \"bold\"),\n    axis.title = element_text(size = 12),\n    legend.title = element_text(size = 12),\n    legend.text = element_text(size = 10)\n  ) +\n  scale_y_continuous(labels = dollar_format())\n\n\n\n\n\n\n\n\n\nPara facilitar a comparação entre os ativos, vamos normalizar os preços para base 100:\n\n\nCode\n# Calculando preços normalizados\nfirst_prices &lt;- closing_prices_df[1, tickers]\nnormalized_prices &lt;- closing_prices_df\n\nfor (ticker in tickers) {\n  normalized_prices[[ticker]] &lt;- closing_prices_df[[ticker]] / first_prices[[ticker]] * 100\n}\n\n# Transformando para o formato longo\nnormalized_long &lt;- normalized_prices %&gt;%\n  pivot_longer(cols = all_of(tickers), \n               names_to = \"symbol\", \n               values_to = \"normalized_price\")\n\n# Plotando os preços normalizados\nggplot(normalized_long, aes(x = date, y = normalized_price, color = symbol)) +\n  geom_line(linewidth = 1) +\n  labs(title = \"Preços Normalizados (Base 100)\",\n       x = \"Data\", \n       y = \"Preço Normalizado\",\n       color = \"Ticker\") +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(size = 16, face = \"bold\"),\n    axis.title = element_text(size = 12),\n    legend.title = element_text(size = 12),\n    legend.text = element_text(size = 10)\n  )\n\n\n\n\n\n\n\n\n\n\n\n\nVamos calcular e visualizar os retornos diários, bem como algumas estatísticas importantes:\n\n\nCode\n# Calculando retornos diários\nreturns &lt;- ROC(closing_prices, type = \"discrete\", n = 1)\nreturns &lt;- returns[-1,]  # Removendo a primeira linha (NA)\n\n# Exibindo estatísticas descritivas\nreturns_stats &lt;- data.frame(\n  Ticker = tickers,\n  Mínimo = apply(returns, 2, min, na.rm = TRUE),\n  Q1 = apply(returns, 2, function(x) quantile(x, 0.25, na.rm = TRUE)),\n  Mediana = apply(returns, 2, median, na.rm = TRUE),\n  Média = apply(returns, 2, mean, na.rm = TRUE),\n  Q3 = apply(returns, 2, function(x) quantile(x, 0.75, na.rm = TRUE)),\n  Máximo = apply(returns, 2, max, na.rm = TRUE),\n  Volatilidade_Diária = apply(returns, 2, sd, na.rm = TRUE),\n  Volatilidade_Anual = apply(returns, 2, sd, na.rm = TRUE) * sqrt(252)\n)\n\n# Formatando os números para percentuais\nreturns_stats[, 2:9] &lt;- round(returns_stats[, 2:9] * 100, 2)\n\n# Exibindo estatísticas\nknitr::kable(returns_stats, caption = \"Estatísticas dos Retornos Diários (%)\")\n\n\n\nEstatísticas dos Retornos Diários (%)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTicker\nMínimo\nQ1\nMediana\nMédia\nQ3\nMáximo\nVolatilidade_Diária\nVolatilidade_Anual\n\n\n\n\nNVDA\nNVDA\n-16.97\n-1.60\n0.30\n0.30\n2.21\n24.37\n3.32\n52.74\n\n\nAAPL\nAAPL\n-9.25\n-0.68\n0.12\n0.04\n0.83\n7.26\n1.49\n23.68\n\n\nTSLA\nTSLA\n-15.43\n-2.01\n0.07\n0.12\n2.09\n21.92\n3.78\n59.95\n\n\nMETA\nMETA\n-10.56\n-0.91\n0.16\n0.20\n1.29\n20.32\n2.21\n35.03\n\n\nAMZN\nAMZN\n-8.98\n-0.90\n0.07\n0.12\n1.30\n8.27\n1.90\n30.10\n\n\nMSFT\nMSFT\n-6.18\n-0.71\n0.12\n0.06\n0.92\n7.24\n1.39\n22.11\n\n\n\n\n\n\n\nVamos visualizar a distribuição dos retornos diários para cada ativo:\n\n\nCode\n# Convertendo returns para dataframe\nreturns_df &lt;- as.data.frame(returns)\nreturns_df$date &lt;- as.Date(rownames(returns_df))\n\n# Transformando para o formato longo\nreturns_long &lt;- returns_df %&gt;%\n  pivot_longer(cols = all_of(tickers), \n               names_to = \"symbol\", \n               values_to = \"return\")\n\n# Plotando histogramas dos retornos\nggplot(returns_long, aes(x = return)) +\n  geom_histogram(aes(y = ..density..), bins = 30, fill = \"steelblue\", alpha = 0.7) +\n  geom_density(color = \"red\", linewidth = 1) +\n  geom_vline(aes(xintercept = mean(return, na.rm = TRUE)), \n             color = \"darkred\", linetype = \"dashed\", linewidth = 1) +\n  facet_wrap(~symbol, scales = \"free_y\", ncol = 2) +\n  labs(title = \"Distribuição dos Retornos Diários\",\n       x = \"Retorno Diário\", \n       y = \"Densidade\") +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(size = 16, face = \"bold\"),\n    axis.title = element_text(size = 12),\n    strip.text = element_text(size = 12, face = \"bold\")\n  ) +\n  scale_x_continuous(labels = percent_format())\n\n\n\n\n\n\n\n\n\n\n\n\n\nVamos analisar a correlação entre os retornos das ações para entender como esses ativos se movimentam em relação uns aos outros:\n\n\nCode\n# Calculando a matriz de correlação\ncorrelation_matrix &lt;- cor(returns, use = \"complete.obs\")\n\n# Visualizando a matriz de correlação\ncorrplot(correlation_matrix, method = \"color\", \n         type = \"upper\", order = \"hclust\", \n         addCoef.col = \"black\", \n         tl.col = \"black\", tl.srt = 45,\n         col = brewer.pal(n = 8, name = \"RdYlBu\"),\n         title = \"Matriz de Correlação dos Retornos Diários\",\n         mar = c(0,0,2,0))\n\n\n\n\n\n\n\n\n\n\n\n\nVamos comparar o risco (volatilidade) e o retorno médio anualizado de cada ativo:\n\n\nCode\n# Calculando retornos médios anualizados e volatilidade anualizada\nmean_return &lt;- colMeans(returns, na.rm = TRUE) * 252\nvolatility &lt;- apply(returns, 2, sd, na.rm = TRUE) * sqrt(252)\n\n# Criando um dataframe para visualização\nrisk_return &lt;- data.frame(\n  Ticker = tickers,\n  Retorno_Anualizado = mean_return,\n  Volatilidade = volatility\n)\n\n# Exibindo a tabela\nknitr::kable(risk_return, digits = 4, \n             col.names = c(\"Ticker\", \"Retorno Anualizado\", \"Volatilidade\"),\n             caption = \"Análise de Risco-Retorno\")\n\n\n\nAnálise de Risco-Retorno\n\n\n\nTicker\nRetorno Anualizado\nVolatilidade\n\n\n\n\nNVDA\nNVDA\n0.7592\n0.5274\n\n\nAAPL\nAAPL\n0.1093\n0.2368\n\n\nTSLA\nTSLA\n0.3095\n0.5995\n\n\nMETA\nMETA\n0.4943\n0.3503\n\n\nAMZN\nAMZN\n0.3055\n0.3010\n\n\nMSFT\nMSFT\n0.1425\n0.2211\n\n\n\n\n\n\n\n\n\nCode\n# Calculando médias para divisão dos quadrantes\navg_ret &lt;- mean(risk_return$Retorno_Anualizado)\navg_vol &lt;- mean(risk_return$Volatilidade)\n\n# Criando o gráfico de risco x retorno\nggplot(risk_return, aes(x = Volatilidade, y = Retorno_Anualizado)) +\n  geom_point(aes(color = Ticker), size = 5) +\n  geom_text(aes(label = Ticker), hjust = -0.3, vjust = 0, size = 4) +\n  geom_hline(yintercept = avg_ret, linetype = \"dashed\", color = \"red\", alpha = 0.5) +\n  geom_vline(xintercept = avg_vol, linetype = \"dashed\", color = \"red\", alpha = 0.5) +\n  annotate(\"text\", x = avg_vol * 1.05, y = avg_ret * 1.05, \n           label = \"Alto Retorno\\nAlto Risco\", \n           hjust = 0, vjust = 0, size = 3.5) +\n  annotate(\"text\", x = avg_vol * 0.95, y = avg_ret * 1.05, \n           label = \"Alto Retorno\\nBaixo Risco\", \n           hjust = 1, vjust = 0, size = 3.5) +\n  annotate(\"text\", x = avg_vol * 1.05, y = avg_ret * 0.95, \n           label = \"Baixo Retorno\\nAlto Risco\", \n           hjust = 0, vjust = 1, size = 3.5) +\n  annotate(\"text\", x = avg_vol * 0.95, y = avg_ret * 0.95, \n           label = \"Baixo Retorno\\nBaixo Risco\", \n           hjust = 1, vjust = 1, size = 3.5) +\n  labs(title = \"Análise de Risco x Retorno\",\n       x = \"Risco (Volatilidade Anualizada)\", \n       y = \"Retorno Médio Anualizado\",\n       color = \"Ticker\") +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(size = 16, face = \"bold\"),\n    axis.title = element_text(size = 12),\n    legend.position = \"top\"\n  ) +\n  scale_y_continuous(labels = percent_format()) +\n  scale_x_continuous(labels = percent_format())\n\n\n\n\n\n\n\n\n\n\n\n\n\nVamos calcular e visualizar o retorno cumulativo para cada ativo:\n\n\nCode\n# Calculando retorno cumulativo\ncumulative_returns &lt;- cumprod(1 + returns) - 1\n\n# Convertendo para dataframe\ncumret_df &lt;- as.data.frame(cumulative_returns)\ncumret_df$date &lt;- as.Date(rownames(cumret_df))\n\n# Transformando para o formato longo\ncumret_long &lt;- cumret_df %&gt;%\n  pivot_longer(cols = all_of(tickers), \n               names_to = \"symbol\", \n               values_to = \"cum_return\")\n\n# Plotando retorno cumulativo\nggplot(cumret_long, aes(x = date, y = cum_return, color = symbol)) +\n  geom_line(linewidth = 1) +\n  labs(title = \"Retorno Cumulativo\",\n       x = \"Data\", \n       y = \"Retorno Cumulativo\",\n       color = \"Ticker\") +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(size = 16, face = \"bold\"),\n    axis.title = element_text(size = 12),\n    legend.title = element_text(size = 12),\n    legend.text = element_text(size = 10)\n  ) +\n  scale_y_continuous(labels = percent_format())\n\n\n\n\n\n\n\n\n\n\n\n\nVamos analisar o volume de negociação para cada ativo:\n\n\nCode\n# Função para extrair volume\nget_volume &lt;- function(ticker) {\n  return(Vo(get(ticker)))\n}\n\n# Obtendo dados de volume\nvolumes &lt;- do.call(merge, lapply(tickers, get_volume))\ncolnames(volumes) &lt;- tickers\n\n# Calculando volume médio diário\navg_volume &lt;- colMeans(volumes, na.rm = TRUE)\navg_volume_df &lt;- data.frame(\n  Ticker = tickers,\n  Volume_Medio = avg_volume\n)\n\n# Ordenando por volume\navg_volume_df &lt;- avg_volume_df[order(avg_volume_df$Volume_Medio, decreasing = TRUE), ]\navg_volume_df$Ticker &lt;- factor(avg_volume_df$Ticker, levels = avg_volume_df$Ticker)\n\n# Plotando o volume médio de negociação\nggplot(avg_volume_df, aes(x = Ticker, y = Volume_Medio / 1e6)) +\n  geom_bar(stat = \"identity\", fill = \"steelblue\") +\n  geom_text(aes(label = sprintf(\"%.1f M\", Volume_Medio / 1e6)), \n            vjust = -0.5, size = 4) +\n  labs(title = \"Volume Médio Diário de Negociação\",\n       x = \"Ticker\", \n       y = \"Volume Médio (Milhões)\") +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(size = 16, face = \"bold\"),\n    axis.title = element_text(size = 12),\n    axis.text.x = element_text(size = 10, angle = 0)\n  )\n\n\n\n\n\n\n\n\n\n\n\n\nVamos calcular a volatilidade móvel para analisar como a volatilidade de cada ativo evolui ao longo do tempo:\n\n\nCode\n# Função para calcular volatilidade móvel\ncalculate_rolling_vol &lt;- function(returns_xts, window_size = 30) {\n  roll_vol &lt;- rollapply(returns_xts, width = window_size, \n                        FUN = function(x) sd(x, na.rm = TRUE) * sqrt(252),\n                        by.column = TRUE, align = \"right\")\n  return(roll_vol)\n}\n\n# Calculando volatilidade móvel (janela de 30 dias)\nrolling_vol &lt;- calculate_rolling_vol(returns, window_size = 30)\n\n# Convertendo para dataframe\nroll_vol_df &lt;- as.data.frame(rolling_vol)\nroll_vol_df$date &lt;- as.Date(rownames(roll_vol_df))\n\n# Transformando para o formato longo\nroll_vol_long &lt;- roll_vol_df %&gt;%\n  pivot_longer(cols = all_of(tickers), \n               names_to = \"symbol\", \n               values_to = \"volatility\")\n\n# Plotando a volatilidade móvel\nggplot(roll_vol_long, aes(x = date, y = volatility, color = symbol)) +\n  geom_line(linewidth = 1) +\n  labs(title = \"Volatilidade Móvel (30 dias)\",\n       x = \"Data\", \n       y = \"Volatilidade Anualizada\",\n       color = \"Ticker\") +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(size = 16, face = \"bold\"),\n    axis.title = element_text(size = 12),\n    legend.title = element_text(size = 12),\n    legend.text = element_text(size = 10)\n  ) +\n  scale_y_continuous(labels = percent_format())\n\n\n\n\n\n\n\n\n\n\n\n\nO Índice Sharpe é uma medida importante que ajuda a avaliar o retorno ajustado ao risco:\n\n\nCode\n# Assumindo taxa livre de risco de 4% ao ano\nrisk_free_rate &lt;- 0.04/252\n\n# Calculando Sharpe Ratio para cada ativo\nsharpe_ratio &lt;- (colMeans(returns, na.rm = TRUE) - risk_free_rate) / \n                 apply(returns, 2, sd, na.rm = TRUE) * sqrt(252)\n\nsharpe_df &lt;- data.frame(\n  Ticker = tickers,\n  Sharpe_Ratio = sharpe_ratio\n)\n\n# Ordenando por Sharpe Ratio\nsharpe_df &lt;- sharpe_df[order(sharpe_df$Sharpe_Ratio, decreasing = TRUE), ]\nsharpe_df$Ticker &lt;- factor(sharpe_df$Ticker, levels = sharpe_df$Ticker)\n\n# Plotando o Sharpe Ratio\nggplot(sharpe_df, aes(x = Ticker, y = Sharpe_Ratio)) +\n  geom_bar(stat = \"identity\", fill = \"darkgreen\") +\n  geom_text(aes(label = sprintf(\"%.2f\", Sharpe_Ratio)), \n            vjust = -0.5, size = 4) +\n  labs(title = \"Índice de Sharpe (Anualizado)\",\n       subtitle = \"Taxa livre de risco = 4%\",\n       x = \"Ticker\", \n       y = \"Sharpe Ratio\") +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(size = 16, face = \"bold\"),\n    plot.subtitle = element_text(size = 12),\n    axis.title = element_text(size = 12),\n    axis.text.x = element_text(size = 10, angle = 0)\n  )\n\n\n\n\n\n\n\n\n\n\n\n\nNa próxima etapa do projeto, iremos:\n\nRealizar uma análise mais aprofundada do desempenho histórico desses ativos\nCalcular métricas adicionais como Sortino Ratio e Maximum Drawdown\nOtimizar a alocação de ativos usando técnicas como a Teoria Moderna de Portfólio\nRealizar backtesting de diferentes estratégias de rebalanceamento\nAnalisar a exposição da carteira a diferentes fatores de risco\n\n\n\n\nCom base nas análises realizadas, podemos destacar os seguintes pontos:\n\nDesempenho: Observamos diferenças significativas no desempenho dos ativos selecionados, com alguns apresentando retornos superiores à média do grupo.\nCorrelação: A matriz de correlação mostra que, apesar de todas serem empresas de tecnologia, há diversificação significativa dentro da carteira.\nRisco-Retorno: O gráfico de risco x retorno nos permite identificar quais ativos oferecem melhor relação entre retorno e volatilidade.\nVolatilidade: A análise de volatilidade móvel mostra períodos de maior e menor instabilidade no mercado, afetando todos os ativos.\nEficiência: A análise do Índice de Sharpe revela quais ativos oferecem melhor retorno ajustado ao risco.\n\nEsta análise preliminar nos dá uma base para entender o comportamento dos ativos selecionados e a dinâmica entre eles, orientando nossas decisões futuras de investimento."
  },
  {
    "objectID": "semana1.html#introdução",
    "href": "semana1.html#introdução",
    "title": "Semana 1: Análise de Carteira de Investimentos",
    "section": "",
    "text": "Neste projeto, analisaremos uma carteira de investimentos composta por seis empresas líderes de tecnologia. A seleção foi feita com base na relevância destas empresas no setor tecnológico, sua capitalização de mercado e potencial de crescimento."
  },
  {
    "objectID": "semana1.html#seleção-de-empresas",
    "href": "semana1.html#seleção-de-empresas",
    "title": "Semana 1: Análise de Carteira de Investimentos",
    "section": "",
    "text": "Nossa carteira é composta pelos seguintes ativos:\n\nNVDA (NVIDIA Corporation)\nAAPL (Apple Inc.)\nTSLA (Tesla, Inc.)\nMETA (Meta Platforms, Inc.)\nAMZN (Amazon.com, Inc.)\nMSFT (Microsoft Corporation)"
  },
  {
    "objectID": "semana1.html#justificativa-da-escolha",
    "href": "semana1.html#justificativa-da-escolha",
    "title": "Semana 1: Análise de Carteira de Investimentos",
    "section": "",
    "text": "A carteira foi estruturada com base nos seguintes critérios:\n\nDiversificação dentro do setor tecnológico: Embora todas sejam empresas de tecnologia, cada uma atua em segmentos distintos - hardware, software, redes sociais, comércio eletrônico, veículos elétricos e inteligência artificial.\nExposição à inovação: Todas as empresas selecionadas investem fortemente em pesquisa e desenvolvimento, com foco em tecnologias emergentes como inteligência artificial, realidade aumentada, computação em nuvem e veículos autônomos.\nLiderança de mercado: Todas são líderes em seus respectivos segmentos, com forte presença global e vantagens competitivas significativas.\nPotencial de crescimento: Apesar de já serem empresas consolidadas, continuam apresentando perspectivas de crescimento em novos mercados e através de inovações disruptivas."
  },
  {
    "objectID": "semana1.html#coleta-de-dados",
    "href": "semana1.html#coleta-de-dados",
    "title": "Semana 1: Análise de Carteira de Investimentos",
    "section": "",
    "text": "Para este projeto, utilizaremos o pacote quantmod em R para coletar os dados históricos de preços das ações selecionadas. Vamos coletar dados dos últimos 2 anos:\n\n\nCode\n# Carregando as bibliotecas necessárias\nlibrary(quantmod)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(corrplot)\nlibrary(RColorBrewer)\nlibrary(scales)\n\n# Definindo os tickers da nossa carteira\ntickers &lt;- c(\"NVDA\", \"AAPL\", \"TSLA\", \"META\", \"AMZN\", \"MSFT\")\n\n# Definindo o período de análise (últimos 2 anos)\nend_date &lt;- Sys.Date()\nstart_date &lt;- end_date - 365*2\n\n# Configurando o ambiente gráfico\noptions(repr.plot.width = 12, repr.plot.height = 8)\n\n# Função para adicionar sufixo ao ticker para Yahoo Finance\nadd_yahoo_suffix &lt;- function(ticker) {\n  return(paste0(ticker, \".US\"))\n}\n\n# Coletando dados históricos\ngetSymbols(tickers, src = \"yahoo\", from = start_date, to = end_date)\n\n\n[1] \"NVDA\" \"AAPL\" \"TSLA\" \"META\" \"AMZN\" \"MSFT\"\n\n\nCode\n# Exibindo as primeiras linhas dos dados da NVIDIA como exemplo\nhead(NVDA)\n\n\n           NVDA.Open NVDA.High NVDA.Low NVDA.Close NVDA.Volume NVDA.Adjusted\n2023-04-10    26.823    27.621   26.669     27.579   395279000      27.56110\n2023-04-11    27.724    27.790   27.126     27.169   314378000      27.15137\n2023-04-12    27.370    27.468   26.448     26.495   446259000      26.47780\n2023-04-13    26.734    26.887   26.329     26.463   353615000      26.44583\n2023-04-14    26.504    26.883   26.220     26.758   395660000      26.74063\n2023-04-17    26.565    27.006   26.433     27.002   321471000      26.98447"
  },
  {
    "objectID": "semana1.html#preparação-dos-dados",
    "href": "semana1.html#preparação-dos-dados",
    "title": "Semana 1: Análise de Carteira de Investimentos",
    "section": "",
    "text": "Vamos organizar os dados para facilitar as análises:\n\n\nCode\n# Função para extrair preços de fechamento ajustados\nget_adjusted_prices &lt;- function(ticker) {\n  return(Ad(get(ticker)))\n}\n\n# Criando um dataframe com os preços de fechamento ajustados\nclosing_prices &lt;- do.call(merge, lapply(tickers, get_adjusted_prices))\ncolnames(closing_prices) &lt;- tickers\n\n# Visualizando as primeiras linhas\nhead(closing_prices)\n\n\n               NVDA     AAPL   TSLA     META   AMZN     MSFT\n2023-04-10 27.56110 160.4123 184.51 213.7426 102.17 284.8594\n2023-04-11 27.15137 159.1946 186.79 212.8468  99.92 278.4021\n2023-04-12 26.47780 158.5016 180.54 212.9961  97.83 279.0518\n2023-04-13 26.44583 163.9070 185.90 219.3164 102.40 285.3024\n2023-04-14 26.74063 163.5605 185.00 220.4510 102.51 281.6603\n2023-04-17 26.98447 163.5803 187.04 217.8333 102.74 284.2786\n\n\nCode\n# Convertendo para dataframe para facilitar algumas manipulações\nclosing_prices_df &lt;- as.data.frame(closing_prices)\nclosing_prices_df$date &lt;- as.Date(rownames(closing_prices_df))"
  },
  {
    "objectID": "semana1.html#análise-da-evolução-dos-preços",
    "href": "semana1.html#análise-da-evolução-dos-preços",
    "title": "Semana 1: Análise de Carteira de Investimentos",
    "section": "",
    "text": "Vamos visualizar a evolução dos preços de fechamento ajustados para cada ativo ao longo do tempo:\n\n\nCode\n# Transformando os dados para o formato longo (tidy)\nprices_long &lt;- closing_prices_df %&gt;%\n  pivot_longer(cols = all_of(tickers), \n               names_to = \"symbol\", \n               values_to = \"price\")\n\n# Plotando os preços de fechamento ajustados\nggplot(prices_long, aes(x = date, y = price, color = symbol)) +\n  geom_line(linewidth = 1) +\n  labs(title = \"Preços de Fechamento Ajustados\",\n       x = \"Data\", \n       y = \"Preço ($)\",\n       color = \"Ticker\") +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(size = 16, face = \"bold\"),\n    axis.title = element_text(size = 12),\n    legend.title = element_text(size = 12),\n    legend.text = element_text(size = 10)\n  ) +\n  scale_y_continuous(labels = dollar_format())\n\n\n\n\n\n\n\n\n\nPara facilitar a comparação entre os ativos, vamos normalizar os preços para base 100:\n\n\nCode\n# Calculando preços normalizados\nfirst_prices &lt;- closing_prices_df[1, tickers]\nnormalized_prices &lt;- closing_prices_df\n\nfor (ticker in tickers) {\n  normalized_prices[[ticker]] &lt;- closing_prices_df[[ticker]] / first_prices[[ticker]] * 100\n}\n\n# Transformando para o formato longo\nnormalized_long &lt;- normalized_prices %&gt;%\n  pivot_longer(cols = all_of(tickers), \n               names_to = \"symbol\", \n               values_to = \"normalized_price\")\n\n# Plotando os preços normalizados\nggplot(normalized_long, aes(x = date, y = normalized_price, color = symbol)) +\n  geom_line(linewidth = 1) +\n  labs(title = \"Preços Normalizados (Base 100)\",\n       x = \"Data\", \n       y = \"Preço Normalizado\",\n       color = \"Ticker\") +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(size = 16, face = \"bold\"),\n    axis.title = element_text(size = 12),\n    legend.title = element_text(size = 12),\n    legend.text = element_text(size = 10)\n  )"
  },
  {
    "objectID": "semana1.html#análise-de-retornos",
    "href": "semana1.html#análise-de-retornos",
    "title": "Semana 1: Análise de Carteira de Investimentos",
    "section": "",
    "text": "Vamos calcular e visualizar os retornos diários, bem como algumas estatísticas importantes:\n\n\nCode\n# Calculando retornos diários\nreturns &lt;- ROC(closing_prices, type = \"discrete\", n = 1)\nreturns &lt;- returns[-1,]  # Removendo a primeira linha (NA)\n\n# Exibindo estatísticas descritivas\nreturns_stats &lt;- data.frame(\n  Ticker = tickers,\n  Mínimo = apply(returns, 2, min, na.rm = TRUE),\n  Q1 = apply(returns, 2, function(x) quantile(x, 0.25, na.rm = TRUE)),\n  Mediana = apply(returns, 2, median, na.rm = TRUE),\n  Média = apply(returns, 2, mean, na.rm = TRUE),\n  Q3 = apply(returns, 2, function(x) quantile(x, 0.75, na.rm = TRUE)),\n  Máximo = apply(returns, 2, max, na.rm = TRUE),\n  Volatilidade_Diária = apply(returns, 2, sd, na.rm = TRUE),\n  Volatilidade_Anual = apply(returns, 2, sd, na.rm = TRUE) * sqrt(252)\n)\n\n# Formatando os números para percentuais\nreturns_stats[, 2:9] &lt;- round(returns_stats[, 2:9] * 100, 2)\n\n# Exibindo estatísticas\nknitr::kable(returns_stats, caption = \"Estatísticas dos Retornos Diários (%)\")\n\n\n\nEstatísticas dos Retornos Diários (%)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTicker\nMínimo\nQ1\nMediana\nMédia\nQ3\nMáximo\nVolatilidade_Diária\nVolatilidade_Anual\n\n\n\n\nNVDA\nNVDA\n-16.97\n-1.60\n0.30\n0.30\n2.21\n24.37\n3.32\n52.74\n\n\nAAPL\nAAPL\n-9.25\n-0.68\n0.12\n0.04\n0.83\n7.26\n1.49\n23.68\n\n\nTSLA\nTSLA\n-15.43\n-2.01\n0.07\n0.12\n2.09\n21.92\n3.78\n59.95\n\n\nMETA\nMETA\n-10.56\n-0.91\n0.16\n0.20\n1.29\n20.32\n2.21\n35.03\n\n\nAMZN\nAMZN\n-8.98\n-0.90\n0.07\n0.12\n1.30\n8.27\n1.90\n30.10\n\n\nMSFT\nMSFT\n-6.18\n-0.71\n0.12\n0.06\n0.92\n7.24\n1.39\n22.11\n\n\n\n\n\n\n\nVamos visualizar a distribuição dos retornos diários para cada ativo:\n\n\nCode\n# Convertendo returns para dataframe\nreturns_df &lt;- as.data.frame(returns)\nreturns_df$date &lt;- as.Date(rownames(returns_df))\n\n# Transformando para o formato longo\nreturns_long &lt;- returns_df %&gt;%\n  pivot_longer(cols = all_of(tickers), \n               names_to = \"symbol\", \n               values_to = \"return\")\n\n# Plotando histogramas dos retornos\nggplot(returns_long, aes(x = return)) +\n  geom_histogram(aes(y = ..density..), bins = 30, fill = \"steelblue\", alpha = 0.7) +\n  geom_density(color = \"red\", linewidth = 1) +\n  geom_vline(aes(xintercept = mean(return, na.rm = TRUE)), \n             color = \"darkred\", linetype = \"dashed\", linewidth = 1) +\n  facet_wrap(~symbol, scales = \"free_y\", ncol = 2) +\n  labs(title = \"Distribuição dos Retornos Diários\",\n       x = \"Retorno Diário\", \n       y = \"Densidade\") +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(size = 16, face = \"bold\"),\n    axis.title = element_text(size = 12),\n    strip.text = element_text(size = 12, face = \"bold\")\n  ) +\n  scale_x_continuous(labels = percent_format())"
  },
  {
    "objectID": "semana1.html#análise-de-correlação",
    "href": "semana1.html#análise-de-correlação",
    "title": "Semana 1: Análise de Carteira de Investimentos",
    "section": "",
    "text": "Vamos analisar a correlação entre os retornos das ações para entender como esses ativos se movimentam em relação uns aos outros:\n\n\nCode\n# Calculando a matriz de correlação\ncorrelation_matrix &lt;- cor(returns, use = \"complete.obs\")\n\n# Visualizando a matriz de correlação\ncorrplot(correlation_matrix, method = \"color\", \n         type = \"upper\", order = \"hclust\", \n         addCoef.col = \"black\", \n         tl.col = \"black\", tl.srt = 45,\n         col = brewer.pal(n = 8, name = \"RdYlBu\"),\n         title = \"Matriz de Correlação dos Retornos Diários\",\n         mar = c(0,0,2,0))"
  },
  {
    "objectID": "semana1.html#análise-de-risco-e-retorno",
    "href": "semana1.html#análise-de-risco-e-retorno",
    "title": "Semana 1: Análise de Carteira de Investimentos",
    "section": "",
    "text": "Vamos comparar o risco (volatilidade) e o retorno médio anualizado de cada ativo:\n\n\nCode\n# Calculando retornos médios anualizados e volatilidade anualizada\nmean_return &lt;- colMeans(returns, na.rm = TRUE) * 252\nvolatility &lt;- apply(returns, 2, sd, na.rm = TRUE) * sqrt(252)\n\n# Criando um dataframe para visualização\nrisk_return &lt;- data.frame(\n  Ticker = tickers,\n  Retorno_Anualizado = mean_return,\n  Volatilidade = volatility\n)\n\n# Exibindo a tabela\nknitr::kable(risk_return, digits = 4, \n             col.names = c(\"Ticker\", \"Retorno Anualizado\", \"Volatilidade\"),\n             caption = \"Análise de Risco-Retorno\")\n\n\n\nAnálise de Risco-Retorno\n\n\n\nTicker\nRetorno Anualizado\nVolatilidade\n\n\n\n\nNVDA\nNVDA\n0.7592\n0.5274\n\n\nAAPL\nAAPL\n0.1093\n0.2368\n\n\nTSLA\nTSLA\n0.3095\n0.5995\n\n\nMETA\nMETA\n0.4943\n0.3503\n\n\nAMZN\nAMZN\n0.3055\n0.3010\n\n\nMSFT\nMSFT\n0.1425\n0.2211\n\n\n\n\n\n\n\n\n\nCode\n# Calculando médias para divisão dos quadrantes\navg_ret &lt;- mean(risk_return$Retorno_Anualizado)\navg_vol &lt;- mean(risk_return$Volatilidade)\n\n# Criando o gráfico de risco x retorno\nggplot(risk_return, aes(x = Volatilidade, y = Retorno_Anualizado)) +\n  geom_point(aes(color = Ticker), size = 5) +\n  geom_text(aes(label = Ticker), hjust = -0.3, vjust = 0, size = 4) +\n  geom_hline(yintercept = avg_ret, linetype = \"dashed\", color = \"red\", alpha = 0.5) +\n  geom_vline(xintercept = avg_vol, linetype = \"dashed\", color = \"red\", alpha = 0.5) +\n  annotate(\"text\", x = avg_vol * 1.05, y = avg_ret * 1.05, \n           label = \"Alto Retorno\\nAlto Risco\", \n           hjust = 0, vjust = 0, size = 3.5) +\n  annotate(\"text\", x = avg_vol * 0.95, y = avg_ret * 1.05, \n           label = \"Alto Retorno\\nBaixo Risco\", \n           hjust = 1, vjust = 0, size = 3.5) +\n  annotate(\"text\", x = avg_vol * 1.05, y = avg_ret * 0.95, \n           label = \"Baixo Retorno\\nAlto Risco\", \n           hjust = 0, vjust = 1, size = 3.5) +\n  annotate(\"text\", x = avg_vol * 0.95, y = avg_ret * 0.95, \n           label = \"Baixo Retorno\\nBaixo Risco\", \n           hjust = 1, vjust = 1, size = 3.5) +\n  labs(title = \"Análise de Risco x Retorno\",\n       x = \"Risco (Volatilidade Anualizada)\", \n       y = \"Retorno Médio Anualizado\",\n       color = \"Ticker\") +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(size = 16, face = \"bold\"),\n    axis.title = element_text(size = 12),\n    legend.position = \"top\"\n  ) +\n  scale_y_continuous(labels = percent_format()) +\n  scale_x_continuous(labels = percent_format())"
  },
  {
    "objectID": "semana1.html#análise-de-desempenho-cumulativo",
    "href": "semana1.html#análise-de-desempenho-cumulativo",
    "title": "Semana 1: Análise de Carteira de Investimentos",
    "section": "",
    "text": "Vamos calcular e visualizar o retorno cumulativo para cada ativo:\n\n\nCode\n# Calculando retorno cumulativo\ncumulative_returns &lt;- cumprod(1 + returns) - 1\n\n# Convertendo para dataframe\ncumret_df &lt;- as.data.frame(cumulative_returns)\ncumret_df$date &lt;- as.Date(rownames(cumret_df))\n\n# Transformando para o formato longo\ncumret_long &lt;- cumret_df %&gt;%\n  pivot_longer(cols = all_of(tickers), \n               names_to = \"symbol\", \n               values_to = \"cum_return\")\n\n# Plotando retorno cumulativo\nggplot(cumret_long, aes(x = date, y = cum_return, color = symbol)) +\n  geom_line(linewidth = 1) +\n  labs(title = \"Retorno Cumulativo\",\n       x = \"Data\", \n       y = \"Retorno Cumulativo\",\n       color = \"Ticker\") +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(size = 16, face = \"bold\"),\n    axis.title = element_text(size = 12),\n    legend.title = element_text(size = 12),\n    legend.text = element_text(size = 10)\n  ) +\n  scale_y_continuous(labels = percent_format())"
  },
  {
    "objectID": "semana1.html#volume-de-negociação",
    "href": "semana1.html#volume-de-negociação",
    "title": "Semana 1: Análise de Carteira de Investimentos",
    "section": "",
    "text": "Vamos analisar o volume de negociação para cada ativo:\n\n\nCode\n# Função para extrair volume\nget_volume &lt;- function(ticker) {\n  return(Vo(get(ticker)))\n}\n\n# Obtendo dados de volume\nvolumes &lt;- do.call(merge, lapply(tickers, get_volume))\ncolnames(volumes) &lt;- tickers\n\n# Calculando volume médio diário\navg_volume &lt;- colMeans(volumes, na.rm = TRUE)\navg_volume_df &lt;- data.frame(\n  Ticker = tickers,\n  Volume_Medio = avg_volume\n)\n\n# Ordenando por volume\navg_volume_df &lt;- avg_volume_df[order(avg_volume_df$Volume_Medio, decreasing = TRUE), ]\navg_volume_df$Ticker &lt;- factor(avg_volume_df$Ticker, levels = avg_volume_df$Ticker)\n\n# Plotando o volume médio de negociação\nggplot(avg_volume_df, aes(x = Ticker, y = Volume_Medio / 1e6)) +\n  geom_bar(stat = \"identity\", fill = \"steelblue\") +\n  geom_text(aes(label = sprintf(\"%.1f M\", Volume_Medio / 1e6)), \n            vjust = -0.5, size = 4) +\n  labs(title = \"Volume Médio Diário de Negociação\",\n       x = \"Ticker\", \n       y = \"Volume Médio (Milhões)\") +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(size = 16, face = \"bold\"),\n    axis.title = element_text(size = 12),\n    axis.text.x = element_text(size = 10, angle = 0)\n  )"
  },
  {
    "objectID": "semana1.html#análise-de-volatilidade-ao-longo-do-tempo",
    "href": "semana1.html#análise-de-volatilidade-ao-longo-do-tempo",
    "title": "Semana 1: Análise de Carteira de Investimentos",
    "section": "",
    "text": "Vamos calcular a volatilidade móvel para analisar como a volatilidade de cada ativo evolui ao longo do tempo:\n\n\nCode\n# Função para calcular volatilidade móvel\ncalculate_rolling_vol &lt;- function(returns_xts, window_size = 30) {\n  roll_vol &lt;- rollapply(returns_xts, width = window_size, \n                        FUN = function(x) sd(x, na.rm = TRUE) * sqrt(252),\n                        by.column = TRUE, align = \"right\")\n  return(roll_vol)\n}\n\n# Calculando volatilidade móvel (janela de 30 dias)\nrolling_vol &lt;- calculate_rolling_vol(returns, window_size = 30)\n\n# Convertendo para dataframe\nroll_vol_df &lt;- as.data.frame(rolling_vol)\nroll_vol_df$date &lt;- as.Date(rownames(roll_vol_df))\n\n# Transformando para o formato longo\nroll_vol_long &lt;- roll_vol_df %&gt;%\n  pivot_longer(cols = all_of(tickers), \n               names_to = \"symbol\", \n               values_to = \"volatility\")\n\n# Plotando a volatilidade móvel\nggplot(roll_vol_long, aes(x = date, y = volatility, color = symbol)) +\n  geom_line(linewidth = 1) +\n  labs(title = \"Volatilidade Móvel (30 dias)\",\n       x = \"Data\", \n       y = \"Volatilidade Anualizada\",\n       color = \"Ticker\") +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(size = 16, face = \"bold\"),\n    axis.title = element_text(size = 12),\n    legend.title = element_text(size = 12),\n    legend.text = element_text(size = 10)\n  ) +\n  scale_y_continuous(labels = percent_format())"
  },
  {
    "objectID": "semana1.html#análise-de-sharpe-ratio",
    "href": "semana1.html#análise-de-sharpe-ratio",
    "title": "Semana 1: Análise de Carteira de Investimentos",
    "section": "",
    "text": "O Índice Sharpe é uma medida importante que ajuda a avaliar o retorno ajustado ao risco:\n\n\nCode\n# Assumindo taxa livre de risco de 4% ao ano\nrisk_free_rate &lt;- 0.04/252\n\n# Calculando Sharpe Ratio para cada ativo\nsharpe_ratio &lt;- (colMeans(returns, na.rm = TRUE) - risk_free_rate) / \n                 apply(returns, 2, sd, na.rm = TRUE) * sqrt(252)\n\nsharpe_df &lt;- data.frame(\n  Ticker = tickers,\n  Sharpe_Ratio = sharpe_ratio\n)\n\n# Ordenando por Sharpe Ratio\nsharpe_df &lt;- sharpe_df[order(sharpe_df$Sharpe_Ratio, decreasing = TRUE), ]\nsharpe_df$Ticker &lt;- factor(sharpe_df$Ticker, levels = sharpe_df$Ticker)\n\n# Plotando o Sharpe Ratio\nggplot(sharpe_df, aes(x = Ticker, y = Sharpe_Ratio)) +\n  geom_bar(stat = \"identity\", fill = \"darkgreen\") +\n  geom_text(aes(label = sprintf(\"%.2f\", Sharpe_Ratio)), \n            vjust = -0.5, size = 4) +\n  labs(title = \"Índice de Sharpe (Anualizado)\",\n       subtitle = \"Taxa livre de risco = 4%\",\n       x = \"Ticker\", \n       y = \"Sharpe Ratio\") +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(size = 16, face = \"bold\"),\n    plot.subtitle = element_text(size = 12),\n    axis.title = element_text(size = 12),\n    axis.text.x = element_text(size = 10, angle = 0)\n  )"
  },
  {
    "objectID": "semana1.html#próximos-passos",
    "href": "semana1.html#próximos-passos",
    "title": "Semana 1: Análise de Carteira de Investimentos",
    "section": "",
    "text": "Na próxima etapa do projeto, iremos:\n\nRealizar uma análise mais aprofundada do desempenho histórico desses ativos\nCalcular métricas adicionais como Sortino Ratio e Maximum Drawdown\nOtimizar a alocação de ativos usando técnicas como a Teoria Moderna de Portfólio\nRealizar backtesting de diferentes estratégias de rebalanceamento\nAnalisar a exposição da carteira a diferentes fatores de risco"
  },
  {
    "objectID": "semana1.html#conclusões-preliminares",
    "href": "semana1.html#conclusões-preliminares",
    "title": "Semana 1: Análise de Carteira de Investimentos",
    "section": "",
    "text": "Com base nas análises realizadas, podemos destacar os seguintes pontos:\n\nDesempenho: Observamos diferenças significativas no desempenho dos ativos selecionados, com alguns apresentando retornos superiores à média do grupo.\nCorrelação: A matriz de correlação mostra que, apesar de todas serem empresas de tecnologia, há diversificação significativa dentro da carteira.\nRisco-Retorno: O gráfico de risco x retorno nos permite identificar quais ativos oferecem melhor relação entre retorno e volatilidade.\nVolatilidade: A análise de volatilidade móvel mostra períodos de maior e menor instabilidade no mercado, afetando todos os ativos.\nEficiência: A análise do Índice de Sharpe revela quais ativos oferecem melhor retorno ajustado ao risco.\n\nEsta análise preliminar nos dá uma base para entender o comportamento dos ativos selecionados e a dinâmica entre eles, orientando nossas decisões futuras de investimento."
  },
  {
    "objectID": "semana3.html",
    "href": "semana3.html",
    "title": "Semana 3: Feature Engineering em Séries de Ações de Tecnologia",
    "section": "",
    "text": "Este documento demonstra o processo de Feature Engineering aplicado a dados de séries temporais financeiras de grandes empresas de tecnologia, focando em:\n\nDownload de dados de ações via Yahoo Finance\nCálculo de log-retornos e análise de distribuições\nModelagem da volatilidade com abordagem tradicional (janela móvel)\nModelagem GARCH(1,1) para estimar variância condicional\nVisualização e comparação dos resultados"
  },
  {
    "objectID": "semana3.html#introdução-feature-engineering-em-séries-financeiras-de-tech-stocks",
    "href": "semana3.html#introdução-feature-engineering-em-séries-financeiras-de-tech-stocks",
    "title": "Semana 3: Feature Engineering em Séries de Ações de Tecnologia",
    "section": "",
    "text": "Este documento demonstra o processo de Feature Engineering aplicado a dados de séries temporais financeiras de grandes empresas de tecnologia, focando em:\n\nDownload de dados de ações via Yahoo Finance\nCálculo de log-retornos e análise de distribuições\nModelagem da volatilidade com abordagem tradicional (janela móvel)\nModelagem GARCH(1,1) para estimar variância condicional\nVisualização e comparação dos resultados"
  },
  {
    "objectID": "semana3.html#carregando-as-bibliotecas-necessárias",
    "href": "semana3.html#carregando-as-bibliotecas-necessárias",
    "title": "Semana 3: Feature Engineering em Séries de Ações de Tecnologia",
    "section": "Carregando as bibliotecas necessárias",
    "text": "Carregando as bibliotecas necessárias\n\n\nCode\nlibrary(ggplot2)\nlibrary(quantmod)    # Para baixar os dados\nlibrary(tidyverse)   # Para manipulação de dados\nlibrary(timetk)      # Para visualização de séries temporais\nlibrary(lubridate)   # Para manipulação de datas\nlibrary(zoo)         # Para funções rollapply\nlibrary(rugarch)     # Para estimação de modelos GARCH\nlibrary(patchwork)   # Para compor múltiplos gráficos\nlibrary(DT)          # Para exibir tabelas interativas\nlibrary(moments)     # Para calcular momentos estatísticos"
  },
  {
    "objectID": "semana3.html#baixando-dados-financeiros",
    "href": "semana3.html#baixando-dados-financeiros",
    "title": "Semana 3: Feature Engineering em Séries de Ações de Tecnologia",
    "section": "Baixando dados financeiros",
    "text": "Baixando dados financeiros\nVamos baixar dados de ações das principais empresas de tecnologia para os últimos 5 anos.\n\n\nCode\n# Definir os tickers das empresas de tecnologia\ntickers &lt;- c(\"NVDA\", \"AAPL\", \"TSLA\", \"META\", \"AMZN\", \"MSFT\")\n\n# Definir período: últimos 5 anos\nstart_date &lt;- Sys.Date() - years(5)\nend_date   &lt;- Sys.Date()\n\n# Baixar os dados do Yahoo Finance\ngetSymbols(tickers, src = \"yahoo\", from = start_date, to = end_date)\n\n\n[1] \"NVDA\" \"AAPL\" \"TSLA\" \"META\" \"AMZN\" \"MSFT\"\n\n\nCode\n# Selecionar o fechamento ajustado (Adj.Close) e juntar em um único data frame\nprice_list &lt;- lapply(tickers, function(sym) Ad(get(sym)))\ntech_prices &lt;- do.call(merge, price_list)\ncolnames(tech_prices) &lt;- tickers\ntech_prices &lt;- na.omit(tech_prices)\ntech_prices &lt;- tk_tbl(tech_prices, preserve.row.names = TRUE, rename_index = \"date\")\ntech_prices$date &lt;- as.Date(tech_prices$date)\n\n# Exibir as primeiras linhas do dataframe\nhead(tech_prices)\n\n\n# A tibble: 6 × 7\n  date        NVDA  AAPL  TSLA  META  AMZN  MSFT\n  &lt;date&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 2020-04-07  6.45  63.0  36.4  168.  101.  156.\n2 2020-04-08  6.65  64.6  36.6  173.  102.  158.\n3 2020-04-09  6.55  65.0  38.2  174.  102.  158.\n4 2020-04-13  6.72  66.3  43.4  174.  108.  158.\n5 2020-04-14  7.07  69.7  47.3  177.  114.  166.\n6 2020-04-15  7.00  69.0  48.7  176.  115.  165."
  },
  {
    "objectID": "semana3.html#visualizando-os-preços",
    "href": "semana3.html#visualizando-os-preços",
    "title": "Semana 3: Feature Engineering em Séries de Ações de Tecnologia",
    "section": "Visualizando os preços",
    "text": "Visualizando os preços\n\n\nCode\n# Convertendo para formato longo para melhor visualização\nprices_long &lt;- tech_prices %&gt;%\n  pivot_longer(-date, names_to = \"Ativo\", values_to = \"Preco\")\n\n# Plotando os preços\nprices_long %&gt;%\n  group_by(Ativo) %&gt;%\n  plot_time_series(\n    .date_var = date,\n    .value = Preco,\n    .title = \"Preços de Fechamento Ajustados das Ações de Tecnologia\",\n    .facet_ncol = 2,\n    .interactive = FALSE\n  )"
  },
  {
    "objectID": "semana3.html#normalizando-os-preços-base-100",
    "href": "semana3.html#normalizando-os-preços-base-100",
    "title": "Semana 3: Feature Engineering em Séries de Ações de Tecnologia",
    "section": "Normalizando os preços (Base 100)",
    "text": "Normalizando os preços (Base 100)\nPara melhor comparar o desempenho relativo das ações ao longo do tempo:\n\n\nCode\n# Normalizar os preços (Base 100)\nnormalized_prices &lt;- tech_prices %&gt;%\n  mutate(across(-date, ~.x / first(.x) * 100))\n\n# Converter para formato longo\nnormalized_long &lt;- normalized_prices %&gt;%\n  pivot_longer(-date, names_to = \"Ativo\", values_to = \"Preco_Normalizado\")\n\n# Plotar os preços normalizados\nggplot(normalized_long, aes(x = date, y = Preco_Normalizado, color = Ativo)) +\n  geom_line() +\n  labs(\n    title = \"Desempenho Relativo das Ações (Base 100)\",\n    x = \"Data\",\n    y = \"Preço Normalizado (Base 100)\",\n    color = \"Empresa\"\n  ) +\n  theme_minimal() +\n  scale_color_brewer(palette = \"Set1\")"
  },
  {
    "objectID": "semana3.html#calculando-os-log-retornos",
    "href": "semana3.html#calculando-os-log-retornos",
    "title": "Semana 3: Feature Engineering em Séries de Ações de Tecnologia",
    "section": "Calculando os Log-Retornos",
    "text": "Calculando os Log-Retornos\n\n\nCode\n# Calculando os log-retornos\nlog_returns &lt;- tech_prices %&gt;%\n  mutate(across(-date, ~log(.x / lag(.x)))) %&gt;%\n  na.omit()\n\n# Convertendo para formato longo para visualização\nreturns_long &lt;- log_returns %&gt;%\n  pivot_longer(-date, names_to = \"Ativo\", values_to = \"Retorno\")\n\n# Plotando os retornos\nreturns_long %&gt;%\n  group_by(Ativo) %&gt;%\n  plot_time_series(\n    .date_var = date,\n    .value = Retorno,\n    .title = \"Log-Retornos Diários das Ações de Tecnologia\",\n    .facet_ncol = 2,\n    .interactive = FALSE,\n    .smooth = FALSE\n  )"
  },
  {
    "objectID": "semana3.html#análise-das-distribuições-dos-retornos",
    "href": "semana3.html#análise-das-distribuições-dos-retornos",
    "title": "Semana 3: Feature Engineering em Séries de Ações de Tecnologia",
    "section": "Análise das Distribuições dos Retornos",
    "text": "Análise das Distribuições dos Retornos\n\n\nCode\n# Plotando histogramas dos retornos\nlibrary(timetk)  # Make sure this is loaded\n\n# Plotando histogramas dos retornos\nreturns_long %&gt;%\n  ggplot(aes(x = Retorno, fill = Ativo)) +\n  geom_density(alpha = 0.5) +\n  facet_wrap(~ Ativo, ncol = 2) +\n  theme_minimal() +\n  labs(title = \"Distribuição dos Log-Retornos\")\n\n\n\n\n\n\n\n\n\nCode\n# Calculando estatísticas descritivas\nreturn_stats &lt;- returns_long %&gt;%\n  group_by(Ativo) %&gt;%\n  summarize(\n    Media = mean(Retorno),\n    Mediana = median(Retorno),\n    Desvio_Padrao = sd(Retorno),\n    Assimetria = skewness(Retorno),\n    Curtose = kurtosis(Retorno),\n    Min = min(Retorno),\n    Max = max(Retorno)\n  )\n\ndatatable(return_stats)"
  },
  {
    "objectID": "semana3.html#boxplot-dos-retornos-para-identificação-de-outliers",
    "href": "semana3.html#boxplot-dos-retornos-para-identificação-de-outliers",
    "title": "Semana 3: Feature Engineering em Séries de Ações de Tecnologia",
    "section": "Boxplot dos Retornos para Identificação de Outliers",
    "text": "Boxplot dos Retornos para Identificação de Outliers\n\n\nCode\n# Boxplot dos retornos\nggplot(returns_long, aes(x = Ativo, y = Retorno)) +\n  geom_boxplot() +\n  labs(\n    title = \"Boxplot dos Log-Retornos Diários\",\n    x = \"Empresa\",\n    y = \"Log-Retorno\"\n  ) +\n  theme_minimal() +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1))"
  },
  {
    "objectID": "semana3.html#correlação-entre-os-retornos-das-ações",
    "href": "semana3.html#correlação-entre-os-retornos-das-ações",
    "title": "Semana 3: Feature Engineering em Séries de Ações de Tecnologia",
    "section": "Correlação entre os Retornos das Ações",
    "text": "Correlação entre os Retornos das Ações\n\n\nCode\n# Calculando a matriz de correlação\ncor_matrix &lt;- log_returns %&gt;%\n  select(-date) %&gt;%\n  cor()\n\n# Visualizando a matriz de correlação\ncor_df &lt;- as.data.frame(cor_matrix)\ncor_df$Stock1 &lt;- rownames(cor_df)\ncor_long &lt;- cor_df %&gt;%\n  pivot_longer(-Stock1, names_to = \"Stock2\", values_to = \"Correlation\")\n\n# Plotando o heatmap\nggplot(cor_long, aes(x = Stock1, y = Stock2, fill = Correlation)) +\n  geom_tile() +\n  scale_fill_gradient2(\n    low = \"blue\", mid = \"white\", high = \"red\",\n    midpoint = 0, limits = c(-1, 1)\n  ) +\n  geom_text(aes(label = round(Correlation, 2)), color = \"black\", size = 3) +\n  labs(\n    title = \"Matriz de Correlação dos Log-Retornos\",\n    x = \"\", y = \"\"\n  ) +\n  theme_minimal() +\n  theme(\n    axis.text.x = element_text(angle = 45, hjust = 1),\n    panel.grid = element_blank()\n  )"
  },
  {
    "objectID": "semana3.html#volatilidade-com-abordagem-tradicional-janela-móvel",
    "href": "semana3.html#volatilidade-com-abordagem-tradicional-janela-móvel",
    "title": "Semana 3: Feature Engineering em Séries de Ações de Tecnologia",
    "section": "Volatilidade com Abordagem Tradicional (Janela Móvel)",
    "text": "Volatilidade com Abordagem Tradicional (Janela Móvel)\n\n\nCode\n# Definindo diferentes tamanhos de janela\nwindow_sizes &lt;- c(5, 21, 63)  # 1 semana, 1 mês, 3 meses de negociação\n\n# Função para calcular volatilidade anualizada\ncalculate_annualized_vol &lt;- function(returns, window_size) {\n  # Aplicando rollapply para calcular a volatilidade na janela móvel\n  vol_rolling &lt;- rollapply(returns, width = window_size, FUN = sd, fill = NA, align = \"right\")\n  # Anualizar a volatilidade (multiplicando por raiz de 252 dias de negociação por ano)\n  vol_annualized &lt;- vol_rolling * sqrt(252)\n  return(vol_annualized)\n}\n\n# Calculando volatilidade para diferentes janelas\nvol_results &lt;- list()\n\nfor (size in window_sizes) {\n  # Aplicando a função para cada coluna de retornos\n  vol_df &lt;- log_returns %&gt;%\n    mutate(across(-date, ~calculate_annualized_vol(.x, size)))\n  \n  # Convertendo para formato longo\n  vol_long &lt;- vol_df %&gt;%\n    pivot_longer(-date, names_to = \"Ativo\", values_to = \"Volatilidade\") %&gt;%\n    mutate(Janela = paste0(size, \" dias\"))\n  \n  vol_results[[as.character(size)]] &lt;- vol_long\n}\n\n# Combinando os resultados\nvol_all &lt;- bind_rows(vol_results)\n\n# Plotando a volatilidade anualizada para diferentes janelas\nvol_all %&gt;%\n  filter(!is.na(Volatilidade)) %&gt;%\n  ggplot(aes(x = date, y = Volatilidade, color = Ativo)) +\n  geom_line() +\n  facet_wrap(~ Janela, scales = \"free_y\") +\n  labs(\n    title = \"Volatilidade Anualizada com Diferentes Janelas Móveis\",\n    x = \"Data\",\n    y = \"Volatilidade Anualizada\",\n    color = \"Empresa\"\n  ) +\n  theme_minimal() +\n  scale_color_brewer(palette = \"Set1\")"
  },
  {
    "objectID": "semana3.html#volatilidade-com-garch11",
    "href": "semana3.html#volatilidade-com-garch11",
    "title": "Semana 3: Feature Engineering em Séries de Ações de Tecnologia",
    "section": "Volatilidade com GARCH(1,1)",
    "text": "Volatilidade com GARCH(1,1)\n\n\nCode\n# Especificação do modelo GARCH(1,1) com distribuição t-Student\nspec &lt;- ugarchspec(\n  variance.model = list(model = \"sGARCH\", garchOrder = c(1, 1)),\n  mean.model = list(armaOrder = c(0, 0), include.mean = TRUE),\n  distribution.model = \"std\"\n)\n\n# Lista dos ativos (exceto a coluna \"date\")\nativos &lt;- colnames(log_returns)[-1]\n\n# Data frame para armazenar as volatilidades GARCH\nvar_condicional &lt;- tibble(date = log_returns$date)\n\n# Data frame para os parâmetros do modelo\nparams_list &lt;- list()\n\n# Loop para estimar os modelos para cada ativo\nfor (ativo in ativos) {\n  # Extrair os dados do ativo\n  data_ativo &lt;- log_returns[[ativo]]\n  \n  # Ajustar o modelo GARCH\n  fit &lt;- ugarchfit(spec = spec, data = data_ativo, solver = 'hybrid', silent = TRUE)\n  \n  # Extrair volatilidade condicional (variância)\n  var_cond &lt;- sigma(fit)^2\n  var_condicional[[ativo]] &lt;- var_cond\n  \n  # Extrair os parâmetros\n  par &lt;- coef(fit)\n  alpha &lt;- par[\"alpha1\"]\n  beta  &lt;- par[\"beta1\"]\n  alpha_beta_sum &lt;- alpha + beta\n  \n  interp &lt;- ifelse(alpha_beta_sum &gt;= 0.9,\n                   sprintf(\"Alta persistência (α+β = %.4f)\", alpha_beta_sum),\n                   sprintf(\"Baixa/moderada persistência (α+β = %.4f)\", alpha_beta_sum))\n  \n  params_list[[ativo]] &lt;- tibble(\n    Ativo = ativo,\n    mu = par[\"mu\"],\n    omega = par[\"omega\"],\n    alpha = alpha,\n    beta = beta,\n    `alpha+beta` = alpha_beta_sum,\n    nu = par[\"shape\"],\n    Interpretacao = interp\n  )\n}\n\n# Combinar os parâmetros em um único data frame\ngarch_params &lt;- bind_rows(params_list)"
  },
  {
    "objectID": "semana3.html#parâmetros-do-modelo-garch11",
    "href": "semana3.html#parâmetros-do-modelo-garch11",
    "title": "Semana 3: Feature Engineering em Séries de Ações de Tecnologia",
    "section": "Parâmetros do Modelo GARCH(1,1)",
    "text": "Parâmetros do Modelo GARCH(1,1)\n\n\nCode\n# Exibir tabela de parâmetros\ndatatable(garch_params, options = list(pageLength = 10, scrollX = TRUE))\n\n\n\n\n\n\nCode\n# Visualizar a persistência (alpha + beta)\nggplot(garch_params, aes(x = Ativo, y = `alpha+beta`, fill = Ativo)) +\n  geom_bar(stat = \"identity\") +\n  geom_hline(yintercept = 0.9, linetype = \"dashed\", color = \"red\") +\n  labs(\n    title = \"Persistência da Volatilidade (α+β)\",\n    subtitle = \"Valores próximos a 1 indicam alta persistência dos choques\",\n    x = \"Empresa\",\n    y = \"α+β\"\n  ) +\n  theme_minimal() +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +\n  scale_fill_brewer(palette = \"Set1\")"
  },
  {
    "objectID": "semana3.html#visualizando-a-variância-condicional-garch",
    "href": "semana3.html#visualizando-a-variância-condicional-garch",
    "title": "Semana 3: Feature Engineering em Séries de Ações de Tecnologia",
    "section": "Visualizando a Variância Condicional (GARCH)",
    "text": "Visualizando a Variância Condicional (GARCH)\n\n\nCode\n# Converter o data frame com as variâncias condicionais para formato longo\nvar_cond_long &lt;- var_condicional %&gt;%\n  pivot_longer(-date, names_to = \"Ativo\", values_to = \"Variancia_Condicional\")\n\n# Plotar as séries temporais de variância condicional para todos os ativos\nvar_cond_long %&gt;%\n  group_by(Ativo) %&gt;% \n  plot_time_series(\n    .date_var = date,\n    .value = Variancia_Condicional,\n    .title = \"Variância Condicional Estimada pelo Modelo GARCH(1,1)\",\n    .interactive = FALSE,\n    .facet_ncol = 2,\n    .smooth = FALSE\n  ) +\n  theme_minimal() +\n  labs(x = \"Data\", y = \"Variância Condicional\")"
  },
  {
    "objectID": "semana3.html#volatilidade-anualizada-pelo-garch",
    "href": "semana3.html#volatilidade-anualizada-pelo-garch",
    "title": "Semana 3: Feature Engineering em Séries de Ações de Tecnologia",
    "section": "Volatilidade Anualizada pelo GARCH",
    "text": "Volatilidade Anualizada pelo GARCH\n\n\nCode\n# Calcular a volatilidade anualizada a partir da variância condicional\nvolatility_garch &lt;- var_condicional %&gt;%\n  mutate(across(-date, ~sqrt(.x) * sqrt(252)))  # Anualização (sqrt(252) dias de negociação)\n\n# Converter para formato longo\nvol_garch_long &lt;- volatility_garch %&gt;%\n  pivot_longer(-date, names_to = \"Ativo\", values_to = \"Volatilidade_Anualizada\")\n\n# Plotar a volatilidade anualizada\nggplot(vol_garch_long, aes(x = date, y = Volatilidade_Anualizada, color = Ativo)) +\n  geom_line() +\n  labs(\n    title = \"Volatilidade Anualizada Estimada pelo GARCH(1,1)\",\n    x = \"Data\",\n    y = \"Volatilidade Anualizada\",\n    color = \"Empresa\"\n  ) +\n  theme_minimal() +\n  scale_color_brewer(palette = \"Set1\")"
  },
  {
    "objectID": "semana3.html#comparação-retornos-vs.-volatilidade-garch",
    "href": "semana3.html#comparação-retornos-vs.-volatilidade-garch",
    "title": "Semana 3: Feature Engineering em Séries de Ações de Tecnologia",
    "section": "Comparação: Retornos vs. Volatilidade GARCH",
    "text": "Comparação: Retornos vs. Volatilidade GARCH\nVamos escolher NVDA (NVIDIA) para demonstrar a relação entre retornos e volatilidade condicional:\n\n\nCode\n# Selecionar os dados para \"NVDA\"\nreturns_nvda &lt;- log_returns %&gt;% \n  select(date, NVDA) %&gt;% \n  rename(Return = NVDA)\n\nvol_nvda &lt;- var_condicional %&gt;% \n  select(date, NVDA) %&gt;% \n  rename(Garch_Vol = NVDA)\n\n# Plot de retornos\np_returns &lt;- returns_nvda %&gt;%\n  plot_time_series(\n    date, Return, \n    .title = \"Retornos Diários - NVDA\", \n    .interactive = FALSE, \n    .smooth = FALSE\n  ) +\n  theme_minimal()\n\n# Plot de volatilidade GARCH\np_vol &lt;- vol_nvda %&gt;%\n  plot_time_series(\n    date, Garch_Vol, \n    .title = \"Variância Condicional (GARCH) - NVDA\", \n    .interactive = FALSE, \n    .smooth = FALSE\n  ) +\n  theme_minimal()\n\n# Combinar os dois gráficos verticalmente\np_returns / p_vol"
  },
  {
    "objectID": "semana3.html#comparação-entre-abordagens-de-volatilidade",
    "href": "semana3.html#comparação-entre-abordagens-de-volatilidade",
    "title": "Semana 3: Feature Engineering em Séries de Ações de Tecnologia",
    "section": "Comparação entre Abordagens de Volatilidade",
    "text": "Comparação entre Abordagens de Volatilidade\nVamos comparar a volatilidade tradicional (janela móvel) com a volatilidade GARCH para NVDA:\n\n\nCode\n# Selecionar janela móvel de 21 dias para comparação\nvol_rolling_21 &lt;- log_returns %&gt;%\n  mutate(across(-date, ~calculate_annualized_vol(.x, 21)))\n\n# Selecionar os dados para \"NVDA\"\nvol_rolling_nvda &lt;- vol_rolling_21 %&gt;% \n  select(date, NVDA) %&gt;% \n  rename(Rolling_Vol = NVDA) %&gt;%\n  na.omit()\n\nvol_garch_nvda &lt;- volatility_garch %&gt;%\n  select(date, NVDA) %&gt;%\n  rename(Garch_Vol = NVDA)\n\n# Criar dataframe para comparação\nvolatility_comparison &lt;- vol_rolling_nvda %&gt;%\n  inner_join(vol_garch_nvda, by = \"date\")\n\n# Convertendo a coluna Garch_Vol de xts para valores numéricos simples\nvolatility_comparison &lt;- volatility_comparison %&gt;%\n  mutate(Garch_Vol = as.numeric(Garch_Vol))\n\n# Converter para formato longo\nvolatility_comparison_long &lt;- volatility_comparison %&gt;%\n  pivot_longer(\n    cols = c(Rolling_Vol, Garch_Vol),\n    names_to = \"Metodo\",\n    values_to = \"Volatilidade\"\n  )\n\n# Plotar comparação\nvolatility_comparison_long %&gt;%\n  mutate(Metodo = factor(Metodo, \n                         levels = c(\"Rolling_Vol\", \"Garch_Vol\"),\n                         labels = c(\"Janela Móvel (21 dias)\", \"GARCH(1,1)\"))) %&gt;%\n  ggplot(aes(x = date, y = Volatilidade, color = Metodo)) +\n  geom_line() +\n  labs(\n    title = \"Comparação entre Métodos de Volatilidade - NVDA\",\n    x = \"Data\",\n    y = \"Volatilidade Anualizada\",\n    color = \"Método\"\n  ) +\n  theme_minimal() +\n  scale_color_brewer(palette = \"Set1\")"
  },
  {
    "objectID": "semana3.html#value-at-risk-var-com-garch",
    "href": "semana3.html#value-at-risk-var-com-garch",
    "title": "Semana 3: Feature Engineering em Séries de Ações de Tecnologia",
    "section": "Value at Risk (VaR) com GARCH",
    "text": "Value at Risk (VaR) com GARCH\nO Value at Risk (VaR) é uma medida estatística que estima a perda máxima esperada de um investimento em um período de tempo específico, dado um nível de confiança.\n\n\nCode\n# Calcular o VaR 1-day 95% usando a volatilidade GARCH\nalpha &lt;- 0.05  # Nível de significância (5%)\nq_alpha &lt;- qnorm(alpha)  # Quantil da distribuição normal padrão\n\n# Calcular o VaR para cada ativo\nvar_df &lt;- tibble(date = volatility_garch$date)\n\nfor (ativo in ativos) {\n  # Obter a média dos retornos\n  mu &lt;- mean(log_returns[[ativo]], na.rm = TRUE)\n  \n  # Obter a volatilidade diária (não anualizada)\n  vol_daily &lt;- sqrt(var_condicional[[ativo]])\n  \n  # Calcular o VaR diário (1 dia)\n  var_daily &lt;- mu + q_alpha * vol_daily\n  \n  # Converter para percentual\n  var_pct &lt;- (exp(var_daily) - 1) * 100\n  \n  var_df[[ativo]] &lt;- var_pct\n}\n\n# Converter para formato longo\nvar_long &lt;- var_df %&gt;%\n  pivot_longer(-date, names_to = \"Ativo\", values_to = \"VaR_95\")\n\n# Plotar o VaR 95%\nvar_long %&gt;%\n  group_by(Ativo) %&gt;%\n  plot_time_series(\n    .date_var = date,\n    .value = VaR_95,\n    .title = \"Value at Risk (VaR) Diário a 95% com GARCH\",\n    .facet_ncol = 2,\n    .interactive = FALSE,\n    .smooth = FALSE\n  ) +\n  labs(y = \"VaR Diário (%)\")"
  },
  {
    "objectID": "semana3.html#backtesting-do-var",
    "href": "semana3.html#backtesting-do-var",
    "title": "Semana 3: Feature Engineering em Séries de Ações de Tecnologia",
    "section": "Backtesting do VaR",
    "text": "Backtesting do VaR\nVamos verificar quantas violações do VaR ocorreram (quando o retorno real foi pior que o VaR previsto):\n\n\nCode\n# Converter retornos para percentual\nreturns_pct &lt;- log_returns %&gt;%\n  mutate(across(-date, ~(exp(.x) - 1) * 100))\n\n# Lista para armazenar resultados do backtesting\nbacktesting_results &lt;- list()\n\nfor (ativo in ativos) {\n  # Juntar VaR e retornos reais\n  backtest_df &lt;- tibble(\n    date = var_df$date,\n    VaR = var_df[[ativo]],\n    Return = returns_pct[[ativo]]\n  ) %&gt;%\n    # Identificar violações (retorno &lt; VaR)\n    mutate(Violation = ifelse(Return &lt; VaR, TRUE, FALSE))\n  \n  # Contar violações\n  n_violations &lt;- sum(backtest_df$Violation)\n  expected_violations &lt;- nrow(backtest_df) * alpha\n  \n  backtesting_results[[ativo]] &lt;- tibble(\n    Ativo = ativo,\n    Total_Dias = nrow(backtest_df),\n    Violacoes_Observadas = n_violations,\n    Violacoes_Esperadas = expected_violations,\n    Taxa_Violacao = n_violations / nrow(backtest_df) * 100,\n    Taxa_Esperada = alpha * 100\n  )\n  \n  # Plotar o backtesting para o primeiro ativo apenas\n  if (ativo == ativos[1]) {\n    p_backtest &lt;- ggplot(backtest_df, aes(x = date)) +\n      geom_line(aes(y = Return, color = \"Retorno Real\")) +\n      geom_line(aes(y = VaR, color = \"VaR 95%\")) +\n      geom_point(\n        data = backtest_df %&gt;% filter(Violation),\n        aes(x = date, y = Return),\n        color = \"red\", size = 2\n      ) +\n      labs(\n        title = paste(\"Backtesting do VaR 95% -\", ativo),\n        x = \"Data\",\n        y = \"Retorno (%)\",\n        color = \"\"\n      ) +\n      theme_minimal() +\n      scale_color_manual(values = c(\"Retorno Real\" = \"black\", \"VaR 95%\" = \"blue\"))\n  }\n}\n\n# Combinar resultados de backtesting\nbacktest_summary &lt;- bind_rows(backtesting_results)\ndatatable(backtest_summary)\n\n\n\n\n\n\nCode\n# Mostrar o gráfico de backtesting para o primeiro ativo\np_backtest"
  },
  {
    "objectID": "semana3.html#análise-de-volatilidade-em-diferentes-períodos-de-mercado",
    "href": "semana3.html#análise-de-volatilidade-em-diferentes-períodos-de-mercado",
    "title": "Semana 3: Feature Engineering em Séries de Ações de Tecnologia",
    "section": "Análise de Volatilidade em Diferentes Períodos de Mercado",
    "text": "Análise de Volatilidade em Diferentes Períodos de Mercado\nVamos identificar períodos de alta e baixa volatilidade no mercado:\n\n\nCode\n# Calcular a volatilidade média do mercado (média entre todos os ativos)\nmarket_vol &lt;- volatility_garch %&gt;%\n  mutate(Market_Vol = rowMeans(across(-date))) %&gt;%\n  select(date, Market_Vol)\n\n# Identificar períodos de alta volatilidade (acima do percentil 80)\nhigh_vol_threshold &lt;- quantile(market_vol$Market_Vol, 0.8)\nlow_vol_threshold &lt;- quantile(market_vol$Market_Vol, 0.2)\n\nmarket_vol &lt;- market_vol %&gt;%\n  mutate(\n    Market_State = case_when(\n      Market_Vol &gt;= high_vol_threshold ~ \"Alta Volatilidade\",\n      Market_Vol &lt;= low_vol_threshold ~ \"Baixa Volatilidade\",\n      TRUE ~ \"Volatilidade Normal\"\n    )\n  )\n\n# Plotar a volatilidade do mercado e os estados\nggplot(market_vol, aes(x = date, y = Market_Vol)) +\n  geom_line() +\n  geom_rect(\n    data = market_vol %&gt;% filter(Market_State == \"Alta Volatilidade\"),\n    aes(xmin = date, xmax = lead(date), ymin = -Inf, ymax = Inf),\n    fill = \"red\", alpha = 0.2\n  ) +\n  geom_rect(\n    data = market_vol %&gt;% filter(Market_State == \"Baixa Volatilidade\"),\n    aes(xmin = date, xmax = lead(date), ymin = -Inf, ymax = Inf),\n    fill = \"green\", alpha = 0.2\n  ) +\n  labs(\n    title = \"Volatilidade Média do Mercado de Tech Stocks\",\n    subtitle = \"Períodos de alta volatilidade (vermelho) e baixa volatilidade (verde)\",\n    x = \"Data\",\n    y = \"Volatilidade Anualizada\"\n  ) +\n  theme_minimal()"
  },
  {
    "objectID": "semana3.html#conclusões",
    "href": "semana3.html#conclusões",
    "title": "Semana 3: Feature Engineering em Séries de Ações de Tecnologia",
    "section": "Conclusões",
    "text": "Conclusões\nNesta análise, aplicamos técnicas de feature engineering em séries temporais de ações de empresas de tecnologia:\n\nCorrelação entre Empresas de Tecnologia:\n\nObservamos correlações significativas entre os retornos das ações tecnológicas, indicando movimentos comuns do setor.\n\nVolatilidade Tradicional vs. GARCH:\n\nA volatilidade calculada por janela móvel é mais simples, mas o modelo GARCH(1,1) captura melhor a dinâmica da volatilidade e o efeito clustering.\n\nPersistência da Volatilidade:\n\nTodas as ações analisadas apresentaram alta persistência (α+β &gt; 0.9), indicando que choques têm efeitos duradouros no setor de tecnologia.\n\nValue at Risk:\n\nO backtesting do VaR mostra a eficácia do modelo GARCH em capturar o risco de cauda.\n\nPeríodos de Volatilidade:\n\nIdentificamos claramente períodos de alta e baixa volatilidade no mercado de ações tecnológicas."
  },
  {
    "objectID": "semana3.html#próximos-passos",
    "href": "semana3.html#próximos-passos",
    "title": "Semana 3: Feature Engineering em Séries de Ações de Tecnologia",
    "section": "Próximos Passos",
    "text": "Próximos Passos\nPara enriquecer a análise, poderíamos:\n\nImplementar modelos GARCH assimétricos (EGARCH, GJR-GARCH) para capturar efeitos de alavancagem\nCalcular métricas adicionais como Expected Shortfall\nAnalisar o comportamento da volatilidade em torno de eventos específicos (anúncios de resultados, lançamentos de produtos)\nIncorporar análise de volume nas estimativas de volatilidade\nExpandir para outras setores para comparação\nImplementar modelos de correlação condicional (DCC-GARCH) para análise de portfólio"
  },
  {
    "objectID": "semana3.html#referências",
    "href": "semana3.html#referências",
    "title": "Semana 3: Feature Engineering em Séries de Ações de Tecnologia",
    "section": "Referências",
    "text": "Referências\n\nTsay, R. S. (2010). Analysis of Financial Time Series (3rd ed.). Wiley.\nAlexander, C. (2008). Market Risk Analysis, Volume II: Practical Financial Econometrics. Wiley.\nHull, J. C. (2018). Options, Futures, and Other Derivatives (10th ed.). Pearson.\nEngle, R. F. (2002). Dynamic Conditional Correlation: A Simple Class of Multivariate GARCH Models. Journal of Business & Economic Statistics, 20(3), 339-350."
  }
]